---
title: "常见算法-Java实现"
categories:
  - Java
tags:
  - 算法
---

如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。

# 算法
>算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀

## 排序算法
排序我们需要关注的性能大致有两个：
1. 平均时间复杂度
2. 辅助空间复杂度
3. 排序算法的稳定性

### 内部排序
内部排序，即数据记录在内存中进行排序。排序的算法大体可以分为两种。一种是比较排序，一种是非比较排序。
#### 冒泡排序
![冒泡排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160329100034660-1420925220.gif)
冒泡排序是最容易实现的排序算法，但是他只能针对于少数元素的数列进行排序!

#### 选择排序(不稳定)
![选择排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328195305723-701227998.gif)
每次遍历选择一个最值，放在合适的位置

#### 插入排序
它的工作原理非常类似于我们抓扑克牌.
![插入排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328201132394-577931661.gif)
插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

#### 希尔排序（不稳定）
希尔排序是插入排序的一种改进版本，也叫做递减增量排序。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
![希尔排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328205313363-2043878119.gif)

#### 归并排序
归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。
递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。
Merge操作步骤如下：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列,索引设置为index=0
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

![归并排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328211504519-1388466622.gif)


#### 堆排序（不稳定）
堆排序是指利用堆这种数据结构所设计的一种选择排序算法。
堆是一个完全二叉树，并且父节点总是大于它的子节点。
我们可以定义堆排序的过程：
1. 由输入的无序数组构造一个最大堆，作为初始的无序区
```java
static int BuildHeap(int A[])           // 建堆，时间复杂度O(n)
  {
      int heap_size = A.length;
      for (int i = heap_size / 2 - 1; i >= 0; i--) // 从每一个非叶结点开始向下进行堆调整
      Heapify(A, i, heap_size);
      return heap_size;
  }
static void Heapify(int A[], int i, int size)  // 从A[i]向下进行堆调整
  {
      int left_child = 2 * i + 1;         // 左孩子索引
      int right_child = 2 * i + 2;        // 右孩子索引
      int max = i;                        // 选出当前结点与其左右孩子三者之中的最大值
      if (left_child < size && A[left_child] > A[max])
          max = left_child;
      if (right_child < size && A[right_child] > A[max])
          max = right_child;
      if (max != i)
      {
          swap(A, i, max);                // 把当前结点和它的最大(直接)子节点进行交换
          Heapify(A, max, size);          // 递归调用，继续从交换的结点向下进行堆调整
      }
  }
```
2. 把堆顶元素（最大值）和堆尾元素互换
3. 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整
4. 重复步骤2，直到堆的尺寸为1

**示意图请绘制完全二叉树图，参考代码。**

#### 快速排序（不稳定）
快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：

1. 从序列中挑出一个元素，作为"基准"(pivot).
2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。
3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。
![快速排序示意图](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328215109269-23458370.gif)




#### 基数排序

#### 二叉排序

### 外部排序




## 查找算法
### 二叉查找
### 红黑树
### B/B+/B*树
### R树
### LMS(分别有对应的应用，数据库、HBase)

## 位图
位图解决重复，存在以及排序问题



