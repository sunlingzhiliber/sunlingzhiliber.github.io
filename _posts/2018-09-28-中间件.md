---
layout:     post
title:      Web服务器
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - Web服务器
---

# Web Serve
## Tomcat

Tomcat是一款开源的应用服务器，凭借技术先进、性能稳定、体积小巧、扩展性好，深受开发人员和软件开发商的认可。

![Tomcat架构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181107184142.jpg)

Tomcat中最顶层的容器是server，代表整个服务器。然后是Service，用于提供具体服务，一个Server包含多种Service。

Service主要包括两个部分：Connector和Container。

>Connector用于处理连接相关的事情，并提供Socekt与Request、Response相关的转化。
>Container用于封装和管理Servlet，并完成具体的Request请求。

注意Service可以拥有多个Connector，因为一个服务可以有多个连接，如同时提供Http和Https链接。

### connector

![Connector结构图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181107185532.jpg)

Connector使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。

其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。

1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。
2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。
3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。

## Nginx

### 负载均衡

`nginx`的负载均衡属于`服务器端均衡`，在服务器端拥有服务实例的清单，在服务器进行负载均衡算法分配。

![服务器端负载均衡](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126102548.png)

负载均衡用于从“upstream”模块定义的后端服务器列表中选取一台服务器接受用户的请求。一个最基本的upstream模块是这样的，模块内的server是服务器列表。

```text
#动态服务器组
upstream dynamic_zuoyu {
    server localhost:8080;  #tomcat 7.0
    server localhost:8081;  #tomcat 8.0
    server localhost:8082;  #tomcat 8.5
    server localhost:8083;  #tomcat 9.0
}
```

当然Nginx拥有丰富的负载均衡策略：

| 轮询               | 默认方式        |
|--------------------|-----------------|
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

# Zookeeper

zookeeper是分布式技术很重要的一块内容，这是因为zookeeper用于管理和协调分布式组件，虽然它出自hadoop生态，却用于很多应用当中，基本上有分布式的地方就有zk的存在。

简单说来，zk可以提供全局统一的节点树结构，通过节点来管理资源，同时zk自身是使用集群方式部署的，所以保证自己是高可用的。根据这一特点，它可以作为服务注册中心，还可以实现分布式锁等功能。

# 消息队列


消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。
消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。

![消息队列](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126215734.png)

消息队列是分布式系统中的重要组成组建，使用消息队列主要是为了异步处理请求`提高系统性能`和`消峰、降低系统耦合程度`。

特点：

- 异步性，将耗时的同步操作，通过以发送消息的方式，进行了异步化处理。减少了同步等待的时间
- 松耦合，消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。
- 分布式，通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性
- 可靠性，消息队列一般会把接收到的消息存储到本地硬盘上，这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。

你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。

当然我们要意识到消息队列是一种FIFO的数据结构，因此我们消费的时候必须按照顺序消费，及生产者发送消息1，2，3，消费者必须按照1，2，3来消费。但是我们是不能保证消费的顺序一定的正确，以及我们不能保证消息不被重复消费，或者消息的传输的丢失乃至于数据不一致等等问题，因此引入MQ，务必会提高系统的复杂程度。


## 两种模式

1.点对点模式

生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，所以Queue实现了一个可靠的负载均衡。

2.发布订阅模式

发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到这个消息的拷贝。

消息生产者向频道发布一个消息之后，多个消费者就可以从该频道订阅到这条消息，并进行消费。这里使用的是`发布与订阅模式`，和观察者模式有以下不同：

- 观察者模式中，观察者和事件都知道对方的存在；而发布订阅模式，彼此不知道存在，他们通过频道进行通信。
- 观察者模式是同步的，当事件触发时，观察者调用监听的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。

![区别](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/530764d5-f67f-47a2-8df4-57e8646e1400.png)


## 消息队列的好处

1.通过异步处理提高系统性能

每个接口模块的吞吐能力是有限的，这个上限能力如果决堤，会导致整个系统的崩溃。

![使用消息队列](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181126214731.jpg)

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。

但是我们注意，因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。
因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。

2.降低系统耦合性

我们的系统中如果存在耦合严重的接口，那么每次增加下层接口，都需要对上层的分发接口进行改造。

我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性就会更好一些。

我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：

![生产者消费者模式](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181126220210.jpg)

上图中利用，消息队列，生产者和消费者并没有直接耦合。消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。这就类似于你写信`对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。`

3.性能问题

RPC接口基本上是同步调用的，整体的服务性能遵循“木桶理论”，及依赖于最慢的那个接口。

## 消息队列的缺点

- 系统可用性降低：在加入MQ之后，你需要考虑消息丢失或者MQ宕机的情形。
- 系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
- 一致性问题： 会导致数据不一致的问题。

## 常见问题

1. 引入消息队列之后如何保证高可用性
2. 如何保证消息不被重复消费呢？
3. 如何保证消息的可靠性传输（如何处理消息丢失的问题）？
4. 我该怎么保证从消息队列里拿到的数据按顺序执行？
5. 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
6. 如果让你来开发一个消息队列中间件，你会怎么设计架构？

## RabbitMQ

RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。
我们也将以RabbitMQ为案列来讲解消息队列。

1.生产者和消费者

一个消息一般由两部分组成：消息头和消息体。消息头由一系列的属性组成，属性包括routing-key、priority、delivery-mode等。生产者把消息交给MQ之后，MQ会将消息发给感兴趣的消费者

2.exchange(交换器)

在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。

Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中（根据routing-key），如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。

3.消息队列

Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。

![RabbitMQ使用流程](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181217212701.jpg)

# Dubbo

Dubbo是一款开源的RPC框架，提供了三大核心能力：面向接口的远程方法调用，容错和负载均衡，以及服务自动注册和发现。Dubbo致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。

![Dubbo架构图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126173006.png)

为什么要使用Dubbo：
1.负载均衡--同一个服务部署在不同的机器时该调用那一台机器上的服务。
2.服务调用链路--服务依赖关系复杂，Dubbo解决了服务之间的相互调用。
3.服务访问压力以及时长统计、资源调度和治理——

调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

基于访问压力实时管理集群容量，提高集群利用率。
4.服务降级——某个服务挂掉之后调用备用服务

# zookeeper

ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，是 Google Chubby 的开源实现。
分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协
调/通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列
等功能。



