---
layout:     post
title:      计算机科学
subtitle:   计算机网络
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - TCP/IP
    - UDP
    - OSI
    - HTTP
    - SSH
    - SSL与TLS
    - CDN
    - Cookie 与 Session
    - 代理
---

# 计算机网络

![计算机网络体系结构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928104258.png)

# 协议

## 五层协议

- 应用层：为特定应用程序提供数据传输服务，如HTTP、DNS等服务。数据单位为`报文`。
- 运输层：为进程通过数据传输服务。运输层包含两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为`报文段`。用户数据报协议UDP，提供无连接、尽最大努力的数据传数服务，数据单位为`用户数据报`。TCP主要提供完整性服务，UDP提供及时性服务。
- 网络层：为主机提供数据传输服务。网络层将运输层传递下来的`报文段`和`用户数据报`封装成`分组`。
- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的`分组`封装成`帧`。
- 物理层：考虑在传输媒体上面传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## OSI协议

- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- 会话层：建立及管理会话。

![OSI七层协议](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111604.png)


## TCP/IP协议

计算机与网络设备之间要相互通信，双方就必须基于同样的方法。比如，如何探测到通信目标，
由谁发起通信、用那种语言进行通信、如何结通信都需要预先确定。所有的这一切都需要一种规则，这种规则就协议。

>TCP/IP就是互联网相关的各类协议族的总称

TCP/IP 协议族是一种沙漏形状，中间小两边大，协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。

![TCP/TP协议族](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111701.png)

IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。
IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改
IP间的通信依赖于MAC地址，我们需要通过中转才能到达通信的目的地，因此在中转时，我们需要利用下一站中转设备的MAC地址来搜索下一个中转目标，这里我们将使用到ARP协议(Address Resuolution Protocol)。这个协议可以实现MAC地址和IP地址的映射。

TCP 位于传输层，提供可靠的字节流服务。目的是为了更容易的传送大数据，需要对数据进行分割，以字节流提供护具，而TCP 协议能够确认数据最终是否送达到对方。

### 三次握手

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113415.png)
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009102549.png)

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。
这样就狠明白了，三次握手是为了防止服务器端的一直等待而浪费资源。至于为什么会出现这种情况？`信道是不可靠的`，三次握手就是解决了在不可靠的信道上可靠的传输信息。

### 四次分手

![四次分手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113509.png)
由于TCP连接是全双工的，因此每个方向(读写方向)都必须单独进行关闭。
这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1.服务器读通道关闭
2.客户机写通道关闭
3.客户机读通道关闭
4.服务器写通道关闭

关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。

四次握手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。



## UDP

UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。

UDP 的主要特点是：
1. 无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. 不保证可靠交付，因此主机不需要为此复杂的连接状态表
3. 面向报文的，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。
4. 没有阻塞控制，因此网络出现的拥塞不会使发送方的发送速率降低。
5. 支持一对一、一对多、多对一和多对多的交互通信，也即是提供广播和多播的功能。
6. 首部开销小，首部只有 8 个字节，分为四部分。

UDP 的常用场景：
- 名字转换（DNS）
- 文件传送（TFTP）
- 路由选择协议（RIP）
- IP 地址配置（BOOTP，DHTP）
- 网络管理（SNMP）
- 远程文件服务（NFS）
- IP 电话
- 流式多媒体通信





## TCP和UDP

TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。
TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。
而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。
简单来说就是：
UDP：**单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；**
TCP：**流式，需要建立连接，复杂，可靠 ，有序。**

## DNS协议

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯

DNS 提供了域名和IP之间的相互查找的服务。

- 先在浏览器自身的DNS缓存中搜索
- 如上述步骤未找到，浏览器搜索操作系统本身的DNS缓存
- 如果在系统DNS缓存中未找到，则尝试读取hosts文件，寻找有没有该域名对应的IP
- 如果hosts文件中没找到，浏览器会向本地配置的首选DNS服务器发起域名解析请求 。运营商的DNS服务器首先查找自身的缓存，若找到对应的条目且没有过期，则解析成功。如果没有找到，运营商的DNS代我们的浏览器，以根域名->顶级域名->二级域名->三级域名这样的顺序发起迭代DNS解析请求

## SSH

SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：

- （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
- （2）用户使用这个公钥，将登录密码加密后，发送回来。
- （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。

SSH是如何解决这个问题呢？hot主机需要贴出自己的公钥指纹
所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。

在使用密码登陆时，每次都需要输入密码，非常麻烦。因此SSH提供了公玥登陆。
所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。

登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

- 生成一对密钥 公钥和私钥
- 然后将公钥复制到远程服务器
- 客户端请求连接服务器，服务器将一个随机字符串发送给客户端
- 客户端根据自己的私钥加密这个随机字符串之后再发送给服务器
- 服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。

SSH使用非对称密钥对数据进行加密传输，保证了远程管理数据的安全性。

## 数据在不同层之间的传输传输

数据在向下传输的时候，需要逐步添加下层协议所需要的尾部或者首部，而在向上的过程中不断拆开尾部和首部。

这里以HTTP请求为例子：
![HTTP请求](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929100558.png)

## HTTP协议和IP、DNS、TCP的关系

![三者关系图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929101708.png)

# 代理

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

## 正向代理

正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
![正向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161256.png)

## 反向代理

反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。

![反向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161313.png)

反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。

# HTTP请求

## HTTP/HTTPS 请求

1.请求报文
![请求报文](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008113950.png)

2.响应报文
![响应报文](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008114000.png)

## 请求方法

| 方法 | 描述 |
|------------|--------------|
| GET | GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据. |
| HEAD | HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.可用于确认URI的有效性及资源更新的日期时间； |
| POST | POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用.POST请求可能会导致新的资源的建立和/或已有资源的修改。  |
| PUT | PUT方法用请求有效载荷替换目标资源的所有当前表示。 |
| DELETE | DELETE方法删除指定的资源。 |
| CONNECT | CONNECT方法建立一个到由目标资源标识的服务器的隧道。 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 |
| OPTIONS | OPTIONS方法用于描述目标资源的通信选项。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 |
| TRACE | TRACE方法沿着到目标资源的路径执行一个消息环回测试。 让服务端将之前的请求通信返回给客户端的方法（因此客户端可以得知请求是怎么一步步到服务端的）。主要用于测试或诊断|
| PATCH | PATCH方法用于对资源应用部分修改。 |

## HTTP状态码

| 状态码 | 类别                             | 原因短语                   |
|--------|----------------------------------|----------------------------|
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |


## HTTP加密

HTTP本身是不具备加密的功能的，是使用明文方式进行发送的。
由此带来了三大风险：

- （1）窃听风险（eavesdropping）：第三方可以获知通信内容。

- （2） 篡改风险（tampering）：第三方可以修改通信内容。

- （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

### SSL与TLS

通过SSL(secure socket layer安全套接层)和TLS(transport layer security 安全层传输协议)的配合使用，加密HTTP的通信内容。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

- （1） 所有信息都是加密传播，第三方无法窃听。

- （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。

- （3） 配备身份证书，防止身份被冒充

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题

（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。
上面过程的前两步，又称为"握手阶段"（handshake）。

第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来对称加密接下来的整个对话过程。

![加密](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009194016.png)

1）生成对话密钥一共需要三个随机数
2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"第三个随机数"（非对称加密），无其他作用。
3）服务器公钥放在服务器的数字证书之中。

用SSL建立安全通信线路后，即可在线路上进行HTTP通信，我们称之为HTTPS。
HTTPS=HTTP+加密+认证(双方)+完整性保护
HTTPS是披着SSL外壳的HTTP，通常HTTP直接和TCP通信，但是使用SSL时，则变成HTTP->SSL->TCP

![SSL](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929153112.png)


## HTTP连接管理

![连接管理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008114900.png)

1.短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。
从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；

2.流水线
默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。
**在一个TCP连接内，多个HTTP请求可以并行，下一个HTTP请求在上一个HTTP请求的应答完成之前就发起**

## HTTP缓存

`缓存`是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。

虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。
缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。

另外缓存需要关心 `缓存是否需要更新`。这其中就涉及到了更多的内容了，包括何时更新？如何更新？

下面介绍HTTP之中存在的缓存有：

### 私有浏览器缓存

私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。

### 共享代理缓存

共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

### 服务器缓存

网关缓存、CDN、反向代理缓存和负载均衡器等

## HTTP内容协商

一份特定的文件称为一项资源。当客户端获取资源的时候，会使用其对应的 URL 发送请求。服务器通过这个 URL 来选择它指向的资源的某一变体——每一个变体称为一种展现形式——然后将这个选定的展现形式返回给客户端。整个资源，连同它的各种展现形式，共享一个特定的 URL 。当一项资源被访问的时候，特定展现形式的选取是通过内容协商机制来决定的，并且客户端和服务器端之间存在多种协商方式。

![内容协商示意图](https://mdn.mozillademos.org/files/13789/HTTPNego.png)

## HTTP内容编码

内容编码将实体主体进行压缩，从而减少传输的数据量。

常用的内容编码有：`gzip、compress、deflate、identity`。

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

## HTTP2.0特性

### 首部压缩和首部字段表维护

HTTP/2.0 使用 Huffman 编码对首部字段进行压缩。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。如图所示:

![首部压缩和首部字段表维护](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220325.png)

### 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端

![服务端推送](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220347.png)


### 二进制分帧层

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

![二进制分帧层](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220438.png)

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

![HTTP2.0通信](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220505.png)

# CDN

内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。

CDN的优点：

- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性

JS/CSS的相对引用，直接引用项目对应位置下的文件

```html
<script src="/js/jquery.min.js"></script>
```

JS/CSS的绝对引用，引用其他站点的文件

```html
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"></script>
```

我们在构建项目的时候，为了省事，将资源文件和业务代码一锅炖的合并在了一点。这种项目往往没有具体公网接入需求。适用于小型的，应用服务器压力并不是太大的系统（并发、带宽、存储空间、资源等等）。

但是当系统访问量变高了之后，我们应该怎么办?

我们就可以考虑将资源服务器和应用服务器进行分离。粗暴的理解方式就是，就是应用安在应用服务器（一台或者是集群），资源部署在资源服务器（单台或者是集群），这时候，js以及css的引用就需要更改为绝对URL，指向对应的资源服务器。

网站的访问速度，只基于一点，那就是页面包含的内容传输到用户电脑的速度，服务器搭的再好再完美，如果用户到服务器的链路之间有一段比较缓慢的话，整体速度也会被拉的十分差劲。
那么我们就考虑将我们的js/css放置到CDN上面。

用户在读取网页内容的时候，就会去就近服务器上掏这些js和css，而不是在你的服务器里捞。
好处呢，第一，一般来说，访问速度有保障，稳定性也有保障；第二，你可以省下资源服务器的一部分资源负担，节省空间节省流量，艰苦创业，能省则省啊。

现在我们来介绍一下官方一点的解释：
CDN(Content Delivery Network),即内容分发网络

基本思路：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。

CDN就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。

基本架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成

- 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
- CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
- 用户向CDN的全局负载均衡设备发起内容URL访问请求。
- CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
- 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。
- 全局负载均衡设备把服务器的IP地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

![CDN](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928145439.png)

# Cookie、Session、Token

## cookie

思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

### 用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 创建过程

服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
```

[page content]
客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。
```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。
  `Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`

### JavaScript

浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。

```
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

### HttpOnly

标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。
`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

## session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

HTTP是无状态的协议，因此我们是不能通过HTTP来判别用户状态的，因此在服务器端需要某种机制来识别特定的用户。
这个机制就是session。
服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。(session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。)

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

![Session](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929143233.png)



## Token


# Socket

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（api）。
属于OSI中的会话层。
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。


# WebSocket

为了解决服务器端和客户端双向通信的问题，我们有这样的解决方案：

1. ajax轮询
2. long poll 长轮询
3. HTTP长连接

在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。

WebSocket是一种全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。

一旦服务器和客户端建立起WebSocekt的通信连接，之后所有的通信都依赖该协议进行。当然Websocket依赖HTTP，因此连接的发起方仍是客户端，依赖客户端进行HTTP请求一次握手。
但是连接一旦建议之后，无论服务器端还是客户端都可以给对方发送报文。
特点列举：

- 服务器端推送功能
- WebSoecket是一直连接的状态，减少通信量
  注意为了实现WebSocket，在HTTP连接建立之后，我们还需要进行一次握手“Handshaking”。

![webSocket](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929162949.png)