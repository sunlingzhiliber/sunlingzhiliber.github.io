---
layout:     post
title:      计算机科学
subtitle:   计算机网络
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - TCP/IP
    - UDP
    - OSI
    - HTTP
    - SSH
    - SSL与TLS
    - CDN
    - Cookie 与 Session
    - 代理
---

# 计算机网络

## 主机之间的通信方式

- 客户-服务器(c/s):客户是服务的请求方，服务器是服务的提供方。
- 对等(P2P):不区分客户和服务器。

![C/S and P2P](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928104244.png)

# 计算机网络体系结构

![计算机网络体系结构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928104258.png)

## 1.五层协议

- 应用层：为特定应用程序提供数据传输服务，如HTTP、DNS等服务。数据单位为`报文`。
- 运输层：为进程通过数据传输服务。运输层包含两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为`报文段`。用户数据报协议UDP，提供无连接、尽最大努力的数据传数服务，数据单位为`用户数据报`。TCP主要提供完整性服务，UDP提供及时性服务。
- 网络层：为主机提供数据传输服务。网络层将运输层传递下来的`报文段`和`用户数据报`封装成`分组`。
- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的`分组`封装成`帧`。
- 物理层：考虑在传输媒体上面传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## 2.OSI(七层协议)

其中多了表示层和会话层用途如下：

- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- 会话层：建立及管理会话。

![OSI七层协议](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111604.png)

## TCP/IP

计算机与网络设备之间要相互通信，双方就必须基于同样的方法。比如，如何探测到通信目标，
由谁发起通信、用那种语言进行通信、如何结通信都需要预先确定。所有的这一切都需要一种规则，这种规则就协议。

>TCP/IP就是互联网相关的各类协议族的总称

TCP/IP 协议族是一种沙漏形状，中间小两边大，协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。

![TCP/TP协议族](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111701.png)

### Socket通信

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（api）。
属于OSI中的会话层。
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。

### IP协议

IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改

IP间的通信依赖于MAC地址，我们需要通过中转才能到达通信的目的地，因此在中转时，我们需要利用下一站中转设备的MAC地址来搜索下一个中转目标，这里我们将使用到ARP协议(Address Resuolution Protocol)。这个协议可以实现MAC地址和IP地址的映射。

### TCP协议

TCP 位于传输层，提供可靠的字节流服务。目的是为了更容易的传送大数据，需要对数据进行分割，以字节流提供护具，而TCP 协议能够确认数据最终是否送达到对方。

#### 1.三次握手

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113415.png)
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009102549.png)

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。
这样就狠明白了，三次握手是为了防止服务器端的一直等待而浪费资源。至于为什么会出现这种情况？`信道是不可靠的`，三次握手就是解决了在不可靠的信道上可靠的传输信息。

#### 2.四次握手

![四次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113509.png)
由于TCP连接是全双工的，因此每个方向(读写方向)都必须单独进行关闭。
这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1.服务器读通道关闭
2.客户机写通道关闭
3.客户机读通道关闭
4.服务器写通道关闭

关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。

四次握手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### DNS协议

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯

DNS 提供了域名和IP之间的相互查找的服务。

### HTTP协议和IP、DNS、TCP的关系

![三者关系图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929101708.png)

## 数据的传输过程

数据在向下传输的时候，需要逐步添加下层协议所需要的尾部或者首部，而在向上的过程中不断拆开尾部和首部。

这里以HTTP请求为例子：
![HTTP请求](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929100558.png)

# CDN

JS/CSS的相对引用，直接引用项目对应位置下的文件

```html
<script src="/js/jquery.min.js"></script>
```

JS/CSS的绝对引用，引用其他站点的文件

```html
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"></script>
```

我们在构建项目的时候，为了省事，将资源文件和业务代码一锅炖的合并在了一点。这种项目往往没有具体公网接入需求。适用于小型的，应用服务器压力并不是太大的系统（并发、带宽、存储空间、资源等等）。

但是当系统访问量变高了之后，我们应该怎么办?

我们就可以考虑将资源服务器和应用服务器进行分离。粗暴的理解方式就是，就是应用安在应用服务器（一台或者是集群），资源部署在资源服务器（单台或者是集群），这时候，js以及css的引用就需要更改为绝对URL，指向对应的资源服务器。

网站的访问速度，只基于一点，那就是页面包含的内容传输到用户电脑的速度，服务器搭的再好再完美，如果用户到服务器的链路之间有一段比较缓慢的话，整体速度也会被拉的十分差劲。
那么我们就考虑将我们的js/css放置到CDN上面。

用户在读取网页内容的时候，就会去就近服务器上掏这些js和css，而不是在你的服务器里捞。
好处呢，第一，一般来说，访问速度有保障，稳定性也有保障；第二，你可以省下资源服务器的一部分资源负担，节省空间节省流量，艰苦创业，能省则省啊。

现在我们来介绍一下官方一点的解释：
CDN(Content Delivery Network),即内容分发网络

基本思路：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。

CDN就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。

基本架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成

- 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
- CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
- 用户向CDN的全局负载均衡设备发起内容URL访问请求。
- CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
- 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。
- 全局负载均衡设备把服务器的IP地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

![CDN](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928145439.png)

# 路由器和交换机的区别

工作层次不同：交换机主要工作在数据链路层（第二层）路由器工作在网络层（第三层）。
转发依据不同：交换机转发所依据的对象时：MAC地址。（物理地址）
路由转发所依据的对象是：IP地址。（网络地址）
主要功能不同：交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。
身份不同：交换机是看门大爷，路由是邮差。

# COOKIE和SESSION有什么区别

1.session
HTTP是无状态的协议，因此我们是不能通过HTTP来判别用户状态的，因此在服务器端需要某种机制来识别特定的用户。这个机制就是session。
服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。

2.cookie
思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。(session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。)

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

![Session](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929143233.png)

# 代理

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

## 正向代理

正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
![正向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161256.png)

## 反向代理

反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。

![反向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161313.png)

反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。

# HTTP持久连接

在HTTP协议的初始版本，每进行一次HTTP通信都要断开一次TCP连接。
但是在如今，一个浏览器的HTML页面中往往包含着大量的资源，每次请求都会造成无谓的连接和断开，增加了通信的开销。

为了解决TCP连接问题，就提出了持久连接的说法。(HTTP Persistent Connections,也称为HTTP keep-alive)。它的特点就只要任意一端没有明确的提出断开连接，则保持TCP连接状态。

![HTTP持久连接](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929151055.png)

# HTTP加密

HTTP本身是不具备加密的功能的，是使用明文方式进行发送的。
由此带来了三大风险：

- （1）窃听风险（eavesdropping）：第三方可以获知通信内容。

- （2） 篡改风险（tampering）：第三方可以修改通信内容。

- （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

## 通信加密

通过SSL(secure socket layer安全套接层)和TLS(transport layer security 安全层传输协议)的配合使用，加密HTTP的通信内容。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

- （1） 所有信息都是加密传播，第三方无法窃听。

- （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。

- （3） 配备身份证书，防止身份被冒充

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题
（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
因此，SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。
上面过程的前两步，又称为"握手阶段"（handshake）。

第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来对称加密接下来的整个对话过程。

![加密](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009194016.png)

1）生成对话密钥一共需要三个随机数
2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"第三个随机数"（非对称加密），无其他作用。
3）服务器公钥放在服务器的数字证书之中。

用SSL建立安全通信线路后，即可在线路上进行HTTP通信，我们称之为HTTPS。
HTTPS=HTTP+加密+认证(双方)+完整性保护
HTTPS是披着SSL外壳的HTTP，通常HTTP直接和TCP通信，但是使用SSL时，则变成HTTP->SSL->TCP
![SSL](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929153112.png)

# WebSocket

为了解决服务器端和客户端双向通信的问题，我们有这样的解决方案：

1. ajax轮询
2. long poll 长轮询
3. HTTP长连接

在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。

WebSocket是一种全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。

一旦服务器和客户端建立起WebSocekt的通信连接，之后所有的通信都依赖该协议进行。当然Websocket依赖HTTP，因此连接的发起方仍是客户端，依赖客户端进行HTTP请求一次握手。
但是连接一旦建议之后，无论服务器端还是客户端都可以给对方发送报文。
特点列举：

- 服务器端推送功能
- WebSoecket是一直连接的状态，减少通信量
  注意为了实现WebSocket，在HTTP连接建立之后，我们还需要进行一次握手“Handshaking”。

![webSocket](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929162949.png)

# DHCP (Dynamic Host Configuration Protocol) 

提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址，DNS服务器

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

![DHCP](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008113219.png)

# IP地址和子网掩码

## IP地址分分类

IP地址=网络号+主机号
我们将网络号相同的主机称之为本地网络，网络号不同的主机叫做远程网络主体。本地网络中的主机可以直接互相通信，远程网络中的主机要通过
本地网管(GateWay)来传递转发数据，gateway就是到其他网络的出口，也就是路由器的IP地址，路由器使用的IP地址是本网段中的任何一个地址，通常是该网段的第一个可用地址或者最后一个可用地址。

## 子网划分

将主机号中拿出一部分作为子网，将二级IP地址划分为三级IP地址
IP地址=网络号+子网号+主机号

注意在使用子网时，必须配置`子网掩码`。

子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。
Ip地址：192.168.1.100
子网掩码：255.255.255.0

>子网掩码：用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上.

IP地址与子网掩码 取 ‘与’操作 得到网络地址 192.168.1.0 
IP地址与子网掩码取反 取 ‘与操作’  得到主机地址 100

将网络地址的主机地址全部取1 得到广播地址 192.168.1.255

如果在同一个网络，则可通过ARP发现对应MAC地址直接发送，不再同一个网络就需要将数据传递给本地网管，网管再根据IP地址查询路由表进行转发。
![传输](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008203253.png)

# VPN

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

VPN看起来是只有机构内部的主机进行了通信，但是实际行他仍然使用了公用的互联网。

![VPN](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008211608.png)

## NAT(网络地址转换)

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。

为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。

# HTTP请求和响应

1.请求报文
![请求报文](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008113950.png)

2.响应报文
![响应报文](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008114000.png)

# HTTP状态码

| 状态码 | 类别                             | 原因短语                   |
|--------|----------------------------------|----------------------------|
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

# 连接管理

![连接管理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008114900.png)

1.短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。
从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；

2.流水线
默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。
**在一个TCP连接内，多个HTTP请求可以并行，下一个HTTP请求在上一个HTTP请求的应答完成之前就发起**

# HTTP2.0

## 首部压缩和首部字段表维护

HTTP/2.0 使用 Huffman 编码对首部字段进行压缩。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。如图所示:

![首部压缩和首部字段表维护](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220325.png)

## 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端

![服务端推送](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220347.png)

## 二进制分帧层

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

![二进制分帧层](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220438.png)

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

![HTTP2.0通信](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181008220505.png)

# SSH(Secure Shell)

SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：

- （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
- （2）用户使用这个公钥，将登录密码加密后，发送回来。
- （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。

SSH是如何解决这个问题呢？hot主机需要贴出自己的公钥指纹
所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。

在使用密码登陆时，每次都需要输入密码，非常麻烦。因此SSH提供了公玥登陆。
所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。

登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

- 生成一对密钥 公钥和私钥
- 然后将公钥复制到远程服务器
- 客户端请求连接服务器，服务器将一个随机字符串发送给客户端
- 客户端根据自己的私钥加密这个随机字符串之后再发送给服务器
- 服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。

# 路由器、交换机和集线器

![路由器、交换机和集线器](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009194946.png)
交换机只认MAC地址，交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。

集线器(HUB)是计算机网络中连接多个计算机或其他设备的连接设备，是对网络进行集中管理的最小单元。英文Hub就是中心的意思，像树的主干一样，它是各分支的汇集点。HUB是一个共享设备，主要提供信号放大和中转的功能，它把一个端口接收的所有信号向所有端口分发出去。

# telnet SSH和Mstsc 以及RDP、RFB

Telnet是一种应用层协议，可以实现远程登陆功能。用户使用telnet连接到远程运行telnet服务的设备。
telnet能将用户的键盘指令传到远程主机，同时也能将远程主机的输出通过TCP返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远程主机上。
telnet能够适应操作系统的差异（如回车、换行的表示不同）。它通过将用户键盘输入和命令转换成NVT格式（网络虚拟终端，是一种中间格式）并提交服务器，服务器再将NVT格式转为本地系统所需的格式。
Telnet服务虽然使用方便，但由于其安全性不高，因此目前通常使用SSH(Secure Shell)代替Telnet进行远程管理。SSH是一个在应用程序中提供安全通信的协议，通过SSH可以安全地访问服务器，因为SSH基于成熟的公钥加密体系，把所有传输的数据进行加密，保证数据在传输时不被恶意破坏、泄露和篡改。SSH还是用了多种加密和认证方式，解决了传输中数据加密和身份认证的问题，能有效防止网络嗅探和IP欺骗等攻击。
使用Telnet这个用来访问远程计算机的TCP/IP协议以控制你的网络设备相当于在离开某个建筑时大喊你的用户名和口令。很快会有人进行监听，并且他 们会利用你安全意识的缺乏。
-------------------------

SSH使用非对称密钥对数据进行加密传输，保证了远程管理数据的安全性。

-------------------------
MSTSC(Microsoft terminal services client)是图形化操作，在服务端和客户端之间的连接协议是用的`RDP`(微软的Reomte desktop protocol)，
RDP则将画图的工作交给了客户端，服务器需要了解客户端显示能力的具体情况，以便作出相应调整。

与RDP相关的还有一个`RFB`协议，RFB是在服务器端将窗口在显存中画好之后将图像传给客户端，客户端只充当一个图像解码显示的角色；
>RFB主要传图像，RDP主要传指令。就一般应用而言，RFB数据量太大，RDP对客户端要求较高，因此RFB适用于瘦客户端，RDP适用于低速网络。
