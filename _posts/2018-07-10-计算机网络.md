---
layout:     post
title:      计算机网络
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# 计算机网络

![计算机网络体系结构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928104258.png)

# 协议

计算机与网络设备之间要相互通信，双方就必须基于同样的方法。比如，如何探测到通信目标，
由谁发起通信、用那种语言进行通信、如何结通信都需要预先确定。所有的这一切都需要一种规则，这种规则就协议。

## 五层协议

- 应用层：为特定应用程序提供数据传输服务。数据单位为`报文`。
- 运输层：为进程通过数据传输服务。运输层包含两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为`报文段`。用户数据报协议UDP，提供无连接、尽最大努力的数据传数服务，数据单位为`用户数据报`。TCP主要提供完整性服务，UDP提供及时性服务。
- 网络层：为主机提供数据传输服务。网络层将运输层传递下来的`报文段`或者`用户数据报`封装成`分组packet`。
- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的`分组`封装成`帧frame`。ARP 地址解析协议
- 物理层：考虑在传输媒体上面传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。


## OSI协议

- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- 会话层：建立及管理会话。



![OSI七层协议](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111604.png)


## TCP/IP四层协议

>TCP/IP协议就是互联网相关的各类协议族的总称

TCP/IP 协议族是一种沙漏形状，中间小两边大，协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。

![TCP/TP协议族](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111701.png)

IP网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。其实和IP协议特别相关的还有一个`ICMP`协议，其作用在于解决出错重传问题,从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。当路由器在处理一个数据包的过程中发生了意外，可以通过ICMP向数据包的源端报告有关事件。


TCP 位于运输层，提供可靠的字节流服务。目的是为了更容易的传送大数据，需要对数据进行分割，以字节流提供护具，而TCP 协议能够确认数据最终是否送达到对方。

UDP 与 TCP 同是在网络模型中的传输层的协议。主要特点是，无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。不保证可靠交付，是面向报文的，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。(IP电话和多媒体通信使用UDP)

### UDP和TCP

TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。
TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。
而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。
简单来说就是：
UDP：**单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；**
TCP：**流式，需要建立连接，复杂，可靠 ，有序。**

### 常见应用场景

**TCP** 的常用场景：

- HTTP 超文本传输协议 80
- FTP 文件传输协议 20传输数据(可协商更改) 21传输控制信息
- SMTP 简单邮件传输协议 25 需要账户名和密码登录到SMTP服务器，避免了垃圾邮件
- IMAP4 因特网信息访问协议 143 交互式邮件存取，你在客户端的操作都会反馈到服务器上，服务器和本地的状态一致
- POP3 邮局协议  110 用户从服务器下载到本地，然后删除服务器上的邮件
- TELNET 远程登陆协议 23
- HTTPS 443

**UDP** 的常用场景：

- TFTP 简单文件传输协议 69 只能对文件服务器进行获取和写入文件。
- RIP 路由选择协议 520
- SNMP 简单网络管理协议 161 get或者set报文 162 接受trap报文  在IP网络中管理网络结点，如服务器、工作站、路由器、交换机的协议 。
- BOOTP 引导协议 67 服务器端 68 客户端 为局域网中的无盘工作站动态分配IP地址
- DHCP 动态主机配置协议   67 服务器端 68 客户端 是Bootp协议的增强版 在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。
- NTP 网络时间协议  123 用于同步计算机的时间
- HTTPS 443

兼有：

- SOCKS 防火墙安全会话转换协议 1080 主要用于客户端与外网服务器之间通讯的中间传递 　当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
- NFS 网络文件服务 能够在本地**透明**读取远端NDF服务器上的文件 局域网使用UDP 广域网使用TCP
- DNS 域名系统 53 建立域名和IP地址之间的映射关系 在`区域之间`传输的时候使用TCP协议，在`域名解析`的是UDP协议。



# TCP的握手、分手

TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。

## 三次握手

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113415.png)
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009102549.png)

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。
这样就狠明白了，三次握手是为了防止服务器端的一直等待而浪费资源。至于为什么会出现这种情况？`信道是不可靠的`，三次握手就是解决了在不可靠的信道上可靠的传输信息。

## 四次分手

![四次分手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113509.png)

由于TCP连接是全双工的，因此每个方向(读写方向)都必须单独进行关闭。

这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。因此需要将两个方向的传输通道 都关闭。

(1)A 发送 Fin 
(2)B 收到，发送 ACK 
(3)B 继续传输数据，直到数据传输完
(4)B 发送 Fin
(5)A 收到，发送ACK


## DNS协议

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯

DNS 提供了域名和IP之间的相互查找的服务。

- 先在浏览器自身的DNS缓存中搜索
- 如上述步骤未找到，浏览器搜索操作系统本身的DNS缓存
- 如果在系统DNS缓存中未找到，则尝试读取hosts文件，寻找有没有该域名对应的IP
- 如果hosts文件中没找到，浏览器会向本地配置的首选DNS服务器发起域名解析请求 。运营商的DNS服务器首先查找自身的缓存，若找到对应的条目且没有过期，则解析成功。如果没有找到，运营商的DNS代我们的浏览器，以根域名->顶级域名->二级域名->三级域名这样的顺序发起迭代DNS解析请求

DNS在区域传输的时候使用TCP协议(不限制长度)，其他使用UDP协议（512字节）。


## SSH

SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：

- （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
- （2）用户使用这个公钥，将登录密码加密后，发送回来。
- （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。

SSH是如何解决这个问题呢？hot主机需要贴出自己的公钥指纹
所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。

在使用密码登陆时，每次都需要输入密码，非常麻烦。因此SSH提供了公玥登陆。
所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。

登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

- 生成一对密钥 公钥和私钥
- 然后将公钥复制到远程服务器
- 客户端请求连接服务器，服务器将一个随机字符串发送给客户端
- 客户端根据自己的私钥加密这个随机字符串之后再发送给服务器
- 服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。

SSH使用非对称密钥对数据进行加密传输，保证了远程管理数据的安全性。

## 数据在不同层之间的传输传输

数据在向下传输的时候，需要逐步添加下层协议所需要的尾部或者首部，而在向上的过程中不断拆开尾部和首部。

依次分别是：

HTTP数据报文->IP数据包->数据帧

这里以HTTP请求为例子：
![HTTP请求](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929100558.png)

## HTTP协议和IP、DNS、TCP的关系

![三者关系图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929101708.png)

# 代理

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

## 正向代理

正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
![正向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161256.png)

## 反向代理

反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。

![反向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161313.png)

反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。



# CDN

内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。

CDN的优点：

- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性

JS/CSS的相对引用，直接引用项目对应位置下的文件

```html
<script src="/js/jquery.min.js"></script>
```

JS/CSS的绝对引用，引用其他站点的文件

```html
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"></script>
```


基本思路：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。

CDN就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。

基本架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成

![CDN](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928145439.png)


# Socket和WebSocket

**Socket**是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（api）。


当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。
建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。
这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。


为了解决服务器端和客户端双向通信的问题，我们通常有这样的解决方案：

- ajax轮询
- long poll 长轮询
- HTTP长连接

在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。

**WebSocket**是一种全双工通信，在webSocket协议下客服端和浏览器可以同时发送信息。

一旦服务器和客户端建立起WebSocekt的通信连接，之后所有的通信都依赖该协议进行。当然Websocket依赖HTTP，因此连接的发起方仍是客户端，依赖客户端进行HTTP请求一次握手。
但是连接一旦建议之后，无论服务器端还是客户端都可以给对方发送报文。
特点列举：

- 服务器端推送功能
- WebSoecket是一直连接的状态，减少通信量
  注意为了实现WebSocket，在HTTP连接建立之后，我们还需要进行一次握手“Handshaking”。

![webSocket](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929162949.png)


# Forward和Redirect

转发是服务器端行为，重定向是客户端行为。

- 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
- 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.
- 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等
- 从效率来说: forward:高. redirect:低.



# 在浏览器中输入URL会发生什么

>尽可能具体，不遗漏任何细节。

以www.baidu.com为例子：

## 按下字母w

大致分为两个部分，一个部分涉及到了计算机硬件和计算机底层的内容。另一部分是浏览器自身的工作。

### 计算机做了什么

在这个时刻，一个专用于`w`的电流回路被直接地或者通过电容器间接地闭合了，使得量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值119。键盘控制器在得到码值之后，将其编码，用于之后的传输。
然后这个'w'是如何绘制到屏幕中搜素框内的呢？操作系统内部维护了一个unsignedchar类型点阵数组fontdata_8x16[]来实现所有ASCII码字符的点阵形状，每一个字符点阵由16个元素构成。对于点阵，他的首地址索引值就是字符的ASCII值，即可根据字的ASCII码值得到字符点阵首地址，

- 首地址为：fontdata_8x16[119*16]的地址。
- 比如字符'w' 他的首地址就是fontdata_8x16[1040]，然后往后面取16个元素。
- 16*16个像素进行描绘。

### 浏览器做了什么

按下某个字母的时候，浏览器接收这个信息，会触发自动完成机制。
浏览器会根据一定的算法，优先考虑你的搜索历史和书签的内容给出建议。并且你的每次按键都会让给出的建议更加确定。

## 按下回车键

### 解析URL

当协议或主机名不合法时，浏览器会将地址栏输入的文字传给默认的搜索引擎。

### urlencode

urlencode实际上是为了在url中支持一些非ascii字符而采用的一种对url进行编码的式。
比如url：`http://localhost:8080/test?id=孙菱志`
url是不支持非ascii字符的，所以就要进行urlencode，而一般浏览器帮我们做这件事(不同浏览器默认编码方式不同)。
编码后的url：`http://localhost:8080/testid=%E5%AD%99%E8%8F%B1%E5%BF%97`。
我们要知道每个操作系统，每个浏览器，每个用户都可以对编码方式进行选择，如果不编码方式进行控制，那么就会存在不同的编码方式。
因此我们在代码中，建议利用js代码对URL进行编码，然后在进行提交。这个时候ascii围外的字符也直接传输。
那么在服务器端接受到数据了 如何进行解码呢？
以tomcat为例，tomcat会自己按照缺省iso-8859-1 对URL进行解码。如果对应的编码码方式不一致，就会导致乱码问题。
在程序里我们可以先以iso-8869-1还原字节码，在使用指定的编码，来获取正确的字段。

```java
String id=new String(req.getParameter("id".getBytes("io-8859-1")),"浏器指定的编码方式")
```

当然，你也可以直接修改tomcat的解码方式为浏览器指定的编码方式。

## 检查HSTS列表

- 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站
- 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送
- 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

## DHCP

如果主机一开没有IP地址，需要DHCP配置IP地址、子网掩码和DNS服务器的IP地址，以及默认网关路由器的地址。

## DNS查询

- 浏览器检查域名是否存在于浏览器缓存之中。(chrome://net-internals/#dns)
- 如果浏览器缓存中没有，就会调用`gethostbyname`库函数进行查询，检查该域名是否存在本地Hosts中(C:\Windows\System32\drivers\etc\hosts)。
- 如果 `gethostbyname`没找到，他就会发送一个UDP包到DNS服务器，DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。
- 查询DNS服务器的MAC地址，如果DNS和主机位于一个子网，直接进行ARP查询(IP地址与MAC地址的转换)，如果不在一个子网，需要对默认网关(gateway)进行递归ARP查询。
- 找到DNS服务器，发送DNS请求，获取目标域名的IP地址，并放入缓存中。

## TCP连接

获取服务器IP后，我们需要构建TCP连接，为了构建TCP连接，我们需要知道本机IP 本机端口 服务器IP 和服务器端口。HTTP服务的端口是80。

- 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)
- TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。
- 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

这个时候经过TCP的 三次握手连接 之后，我们就可以发送HTTP请求了。

## HTTP服务器请求的处理

HTTP请求通过了千山万水，多个路由器(IP数据包在路由器之间转发的使用，又会使用到OPSF协议)，终于抵达服务器，这个时候服务器就开始着手处理了。

我们这里以Nginx继续下面的故事：

- 对于HTTP请求，Nginx读取后，需要判断是静态请求呢还是动态请求。如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。
- 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。

![负载均衡](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115534.png)

例如Ngnix支持这么几种：

| 轮询               | 默认方式        |
|--------------------|-----------------|
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

由此我们最后的连接情况是这样的。
![链接](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115553.png)

到了应用服务器Tomcat，我们又做了些什么呢？一个HTTP request一个servlet 一个controller 一个service 最终返回一个HTTP response。
当response返回到Ngnix，再返回到浏览器后，我们该干嘛呢？

## 浏览器

通常我们的这个response是一个HTML页面。那么我们就开始准备显示这个页面。这个页面中可能包含了大量的静态资源，因此我们又会重复上面的操作，进行静态资源的访问。当然，这里的访问，会由浏览器去创建多个TCP连接，并行的去下载。
注意静态资源在返回时，服务器会告诉浏览器这些文件的过期时间(Cache-Control或者Expire),这是浏览器就会进行缓存。当第二次请求的时候就从缓存中获取。
如果过期了，浏览器会询问服务器是否更改，（依据是依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not
Modified），就继续使用缓存，反之将最新文件返回到浏览器。

## 页面渲染

在得到HTML,CSS,JS之后，就由浏览器去绘制页面即可。



# SSL和TLS HTTPS

起初是因为HTTP在传输数据时使用的是明文，**SSL(安全套接字层协议)**是HTTP之下，TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，从而实现了安全的HTTPS；
SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。

**TLS(输出层安全协议)**是更为安全的升级版的SSL，TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。
`TLS`用于在两个通信应用程序之间提供保密性和数据完整性。


# IP地址

目前我们说得地址基本都是IPV4，及4个字节，32位的一组二进制数字，我们能利用这组数字来唯一标识一台机器。

2^32-1= 4294967296(43亿) 这意味着利用IPV4 我们只能为43亿个主机分配唯一的地址，这是远远不够的。

在还未全面普及IPV6(16个字节，128位)的情况下，我们利用了NAT的技术大大延缓了IVP4的耗尽速度。

## NAT 

网络地址转换(NAT，Network Address Translation),在内网使用内部IP，在向外网访问时，转为为公网IP。一个内网内的所有机器对公网的访问都表现为一台主机。

## IP地址分类

IP地址=网络号 + 主机号

每个网络中主机号为 全'0'和全'1'的地址具有特殊用途，不能分配。

| 类型 | 地址                         | 主机地址范围              | 网络数 | 主机个数 |私有IP |子网掩码|
|------|------------------------------|---------------------------|--------|----------|----------|----------|
| A类  | 0 + 7位网络号 + 24位主机号   | 1.0.0.1~126.255.255.254   | 2^7-2=126    | 2^24-2   |10.0.0.0 ~ 10.255.255.255 |255.0.0.0|
| B类  | 10 + 14位网络号 + 16位主机号 | 128.0.0.1~191.255.255.254 | 2^14  | 2^16-2   |172.16.0.0 ~ 172.31.255.255 |255.255.0.0|
| C类  | 110 + 21位网络号 + 8位主机号 | 192.0.0.1~223.255.255.254 | 2^21  | 2^8-2    |192.168.0.0 ~ 192.168.255.255 |255.255.255.0|

A类 最小 0 000 0001 =1   最大 0 111 1110 = 126
B类 最小 10 00 0000 =128 最大 10 11 1111 = 191
C类 最小 110 0 0000 =192 最大 110 1 1111 = 223

跨网络通信，必须使用到路由器，同一个网络只需要交换机。

.0.0.0是网络地址，不能分配。
.255.255.255是当前网络的广播地址，不能分配