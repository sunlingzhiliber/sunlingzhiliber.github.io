---
layout:     post
title:      计算机科学
subtitle:   计算机网络
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - TCP/IP
    - UDP
    - OSI
    - HTTP
    - SSH
    - SSL与TLS
    - CDN
    - Cookie 与 Session
    - 代理
---

# 计算机网络

![计算机网络体系结构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928104258.png)

# 协议

## 五层协议

- 应用层：为特定应用程序提供数据传输服务，如HTTP、DNS等服务。数据单位为`报文`。
- 运输层：为进程通过数据传输服务。运输层包含两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为`报文段`。用户数据报协议UDP，提供无连接、尽最大努力的数据传数服务，数据单位为`用户数据报`。TCP主要提供完整性服务，UDP提供及时性服务。
- 网络层：为主机提供数据传输服务。网络层将运输层传递下来的`报文段`和`用户数据报`封装成`分组`。
- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的`分组`封装成`帧`。
- 物理层：考虑在传输媒体上面传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## OSI协议

- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- 会话层：建立及管理会话。

![OSI七层协议](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111604.png)


## TCP/IP协议

计算机与网络设备之间要相互通信，双方就必须基于同样的方法。比如，如何探测到通信目标，
由谁发起通信、用那种语言进行通信、如何结通信都需要预先确定。所有的这一切都需要一种规则，这种规则就协议。

>TCP/IP就是互联网相关的各类协议族的总称

TCP/IP 协议族是一种沙漏形状，中间小两边大，协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。

![TCP/TP协议族](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928111701.png)

IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。
IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改
IP间的通信依赖于MAC地址，我们需要通过中转才能到达通信的目的地，因此在中转时，我们需要利用下一站中转设备的MAC地址来搜索下一个中转目标，这里我们将使用到ARP协议(Address Resuolution Protocol)。这个协议可以实现MAC地址和IP地址的映射。

TCP 位于传输层，提供可靠的字节流服务。目的是为了更容易的传送大数据，需要对数据进行分割，以字节流提供护具，而TCP 协议能够确认数据最终是否送达到对方。

### 三次握手

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113415.png)
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

![三次握手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181009102549.png)

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。
这样就狠明白了，三次握手是为了防止服务器端的一直等待而浪费资源。至于为什么会出现这种情况？`信道是不可靠的`，三次握手就是解决了在不可靠的信道上可靠的传输信息。

### 四次分手

![四次分手](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928113509.png)
由于TCP连接是全双工的，因此每个方向(读写方向)都必须单独进行关闭。
这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1.服务器读通道关闭
2.客户机写通道关闭
3.客户机读通道关闭
4.服务器写通道关闭

关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。

四次握手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。



## UDP

UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。

UDP 的主要特点是：
1. 无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. 不保证可靠交付，因此主机不需要为此复杂的连接状态表
3. 面向报文的，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。
4. 没有阻塞控制，因此网络出现的拥塞不会使发送方的发送速率降低。
5. 支持一对一、一对多、多对一和多对多的交互通信，也即是提供广播和多播的功能。
6. 首部开销小，首部只有 8 个字节，分为四部分。

UDP 的常用场景：
- 名字转换（DNS）
- 文件传送（TFTP）
- 路由选择协议（RIP）
- IP 地址配置（BOOTP，DHTP）
- 网络管理（SNMP）
- 远程文件服务（NFS）
- IP 电话
- 流式多媒体通信





## TCP和UDP

TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。
TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。
而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。
简单来说就是：
UDP：**单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；**
TCP：**流式，需要建立连接，复杂，可靠 ，有序。**

## DNS协议

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯

DNS 提供了域名和IP之间的相互查找的服务。

- 先在浏览器自身的DNS缓存中搜索
- 如上述步骤未找到，浏览器搜索操作系统本身的DNS缓存
- 如果在系统DNS缓存中未找到，则尝试读取hosts文件，寻找有没有该域名对应的IP
- 如果hosts文件中没找到，浏览器会向本地配置的首选DNS服务器发起域名解析请求 。运营商的DNS服务器首先查找自身的缓存，若找到对应的条目且没有过期，则解析成功。如果没有找到，运营商的DNS代我们的浏览器，以根域名->顶级域名->二级域名->三级域名这样的顺序发起迭代DNS解析请求

## SSH

SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：

- （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
- （2）用户使用这个公钥，将登录密码加密后，发送回来。
- （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。

SSH是如何解决这个问题呢？hot主机需要贴出自己的公钥指纹
所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。

在使用密码登陆时，每次都需要输入密码，非常麻烦。因此SSH提供了公玥登陆。
所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。

登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

- 生成一对密钥 公钥和私钥
- 然后将公钥复制到远程服务器
- 客户端请求连接服务器，服务器将一个随机字符串发送给客户端
- 客户端根据自己的私钥加密这个随机字符串之后再发送给服务器
- 服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。

SSH使用非对称密钥对数据进行加密传输，保证了远程管理数据的安全性。

## 数据在不同层之间的传输传输

数据在向下传输的时候，需要逐步添加下层协议所需要的尾部或者首部，而在向上的过程中不断拆开尾部和首部。

这里以HTTP请求为例子：
![HTTP请求](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929100558.png)

## HTTP协议和IP、DNS、TCP的关系

![三者关系图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929101708.png)

# 代理

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

## 正向代理

正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
![正向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161256.png)

## 反向代理

反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。

![反向代理](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928161313.png)

反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。



# CDN

内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。

CDN的优点：

- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性

JS/CSS的相对引用，直接引用项目对应位置下的文件

```html
<script src="/js/jquery.min.js"></script>
```

JS/CSS的绝对引用，引用其他站点的文件

```html
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"></script>
```

我们在构建项目的时候，为了省事，将资源文件和业务代码一锅炖的合并在了一点。这种项目往往没有具体公网接入需求。适用于小型的，应用服务器压力并不是太大的系统（并发、带宽、存储空间、资源等等）。

但是当系统访问量变高了之后，我们应该怎么办?

我们就可以考虑将资源服务器和应用服务器进行分离。粗暴的理解方式就是，就是应用安在应用服务器（一台或者是集群），资源部署在资源服务器（单台或者是集群），这时候，js以及css的引用就需要更改为绝对URL，指向对应的资源服务器。

网站的访问速度，只基于一点，那就是页面包含的内容传输到用户电脑的速度，服务器搭的再好再完美，如果用户到服务器的链路之间有一段比较缓慢的话，整体速度也会被拉的十分差劲。
那么我们就考虑将我们的js/css放置到CDN上面。

用户在读取网页内容的时候，就会去就近服务器上掏这些js和css，而不是在你的服务器里捞。
好处呢，第一，一般来说，访问速度有保障，稳定性也有保障；第二，你可以省下资源服务器的一部分资源负担，节省空间节省流量，艰苦创业，能省则省啊。

现在我们来介绍一下官方一点的解释：
CDN(Content Delivery Network),即内容分发网络

基本思路：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。

CDN就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。

基本架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成

- 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
- CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
- 用户向CDN的全局负载均衡设备发起内容URL访问请求。
- CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
- 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。
- 全局负载均衡设备把服务器的IP地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

![CDN](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928145439.png)




# Socket

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（api）。


属于OSI中的会话层。
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。


# WebSocket

为了解决服务器端和客户端双向通信的问题，我们有这样的解决方案：

1. ajax轮询
2. long poll 长轮询
3. HTTP长连接

在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。

WebSocket是一种全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。

一旦服务器和客户端建立起WebSocekt的通信连接，之后所有的通信都依赖该协议进行。当然Websocket依赖HTTP，因此连接的发起方仍是客户端，依赖客户端进行HTTP请求一次握手。
但是连接一旦建议之后，无论服务器端还是客户端都可以给对方发送报文。
特点列举：

- 服务器端推送功能
- WebSoecket是一直连接的状态，减少通信量
  注意为了实现WebSocket，在HTTP连接建立之后，我们还需要进行一次握手“Handshaking”。

![webSocket](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180929162949.png)


# Forward和Redirect

转发是服务器端行为，重定向是客户端行为。

- 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
- 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.
- 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等
- 从效率来说: forward:高. redirect:低.



# 在浏览器中输入URL会发生什么

>尽可能具体，不遗漏任何细节。

以www.baidu.com为例子：

## 按下字母w

大致分为两个部分，一个部分涉及到了计算机硬件和计算机底层的内容。另一部分是浏览器自身的工作。

### 计算机做了什么

在这个时刻，一个专用于`w`的电流回路被直接地或者通过电容器间接地闭合了，使得量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值119。键盘控制器在得到码值之后，将其编码，用于之后的传输。
然后这个'w'是如何绘制到屏幕中搜素框内的呢？操作系统内部维护了一个unsignedchar类型点阵数组fontdata_8x16[]来实现所有ASCII码字符的点阵形状，每一个字符点阵由16个元素构成。对于点阵，他的首地址索引值就是字符的ASCII值，即可根据字的ASCII码值得到字符点阵首地址，

- 首地址为：fontdata_8x16[119*16]的地址。
- 比如字符'w' 他的首地址就是fontdata_8x16[1040]，然后往后面取16个元素。
- 16*16个像素进行描绘。

### 浏览器做了什么

按下某个字母的时候，浏览器接收这个信息，会触发自动完成机制。
浏览器会根据一定的算法，优先考虑你的搜索历史和书签的内容给出建议。并且你的每次按键都会让给出的建议更加确定。

## 按下回车键

### 解析URL

当协议或主机名不合法时，浏览器会将地址栏输入的文字传给默认的搜索引擎。

### urlencode

urlencode实际上是为了在url中支持一些非ascii字符而采用的一种对url进行编码的式。
比如url：`http://localhost:8080/test?id=孙菱志`
url是不支持非ascii字符的，所以就要进行urlencode，而一般浏览器帮我们做这件事(不同浏览器默认编码方式不同)。
编码后的url：`http://localhost:8080/testid=%E5%AD%99%E8%8F%B1%E5%BF%97`。
我们要知道每个操作系统，每个浏览器，每个用户都可以对编码方式进行选择，如果不编码方式进行控制，那么就会存在不同的编码方式。
因此我们在代码中，建议利用js代码对URL进行编码，然后在进行提交。这个时候ascii围外的字符也直接传输。
那么在服务器端接受到数据了 如何进行解码呢？
以tomcat为例，tomcat会自己按照缺省iso-8859-1 对URL进行解码。如果对应的编码码方式不一致，就会导致乱码问题。
在程序里我们可以先以iso-8869-1还原字节码，在使用指定的编码，来获取正确的字段。

```java
String id=new String(req.getParameter("id".getBytes("io-8859-1")),"浏器指定的编码方式")
```

当然，你也可以直接修改tomcat的解码方式为浏览器指定的编码方式。

## 检查HSTS列表

- 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站
- 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送
- 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

## DHCP

如果主机一开没有IP地址，需要DHCP配置IP地址、子网掩码和DNS服务器的IP地址，以及默认网关路由器的地址。

## DNS查询

- 浏览器检查域名是否存在于浏览器缓存之中。(chrome://net-internals/#dns)
- 如果浏览器缓存中没有，就会调用`gethostbyname`库函数进行查询，检查该域名是否存在本地Hosts中(C:\Windows\System32\drivers\etc\hosts)。
- 如果 `gethostbyname`没找到，他就会发送一个UDP包到DNS服务器，DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。
- 查询DNS服务器的MAC地址，如果DNS和主机位于一个子网，直接进行ARP查询(IP地址与MAC地址的转换)，如果不在一个子网，需要对默认网关(gateway)进行递归ARP查询。
- 找到DNS服务器，发送DNS请求，获取目标域名的IP地址，并放入缓存中。

## TCP连接

获取服务器IP后，我们需要构建TCP连接，为了构建TCP连接，我们需要知道本机IP 本机端口 服务器IP 和服务器端口。HTTP服务的端口是80。

- 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)
- TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。
- 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

这个时候经过TCP的 三次握手连接 之后，我们就可以发送HTTP请求了。

## HTTP服务器请求的处理

HTTP请求通过了千山万水，多个路由器(IP数据包在路由器之间转发的使用，又会使用到OPSF协议)，终于抵达服务器，这个时候服务器就开始着手处理了。

我们这里以Nginx继续下面的故事：

- 对于HTTP请求，Nginx读取后，需要判断是静态请求呢还是动态请求。如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。
- 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。

![负载均衡](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115534.png)

例如Ngnix支持这么几种：

| 轮询               | 默认方式        |
|--------------------|-----------------|
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

由此我们最后的连接情况是这样的。
![链接](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115553.png)

到了应用服务器Tomcat，我们又做了些什么呢？一个HTTP request一个servlet 一个controller 一个service 最终返回一个HTTP response。
当response返回到Ngnix，再返回到浏览器后，我们该干嘛呢？

## 浏览器

通常我们的这个response是一个HTML页面。那么我们就开始准备显示这个页面。这个页面中可能包含了大量的静态资源，因此我们又会重复上面的操作，进行静态资源的访问。当然，这里的访问，会由浏览器去创建多个TCP连接，并行的去下载。
注意静态资源在返回时，服务器会告诉浏览器这些文件的过期时间(Cache-Control或者Expire),这是浏览器就会进行缓存。当第二次请求的时候就从缓存中获取。
如果过期了，浏览器会询问服务器是否更改，（依据是依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not
Modified），就继续使用缓存，反之将最新文件返回到浏览器。

## 页面渲染

在得到HTML,CSS,JS之后，就由浏览器去绘制页面即可。


# IP地址与MAC地址的区别

IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。

他们两者可以通过ARP协议进行转换。