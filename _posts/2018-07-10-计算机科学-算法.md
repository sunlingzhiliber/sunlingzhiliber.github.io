---
layout:     post
title:      java-算法
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
    - 算法
---

如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。

# 算法

>算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀

## 加密解密算法

## 排序算法

排序我们需要关注的性能大致有两个：

1. 平均时间复杂度(最慢的排序方法：n的平方 最快的排序方法：nlg2n)
2. 辅助空间复杂度
3. 排序算法的稳定性

### 为什么要分稳定排序和非稳定排序呢

排序的稳定性 就意味着：具有相同value的数在排序后，相对顺序不变。

- 能保证第二次排序好的 序列保持着第一次的排序顺序。 

第一次排序  a=1 b=2;
第二次排序  a=1 b=1; //虽然a、b的value一致，但是采用稳定排序后，还是能保证上次value值低的在前面

- 具有两个排序关键字的时候，可以让key2的value值相等的同学 还是按照key1的value排序。

### 选择排序、冒泡排序、直接插入排序

### 希尔排序

### 堆排序

### 归并排序

### 快速排序(三数取中)



## 红黑树

红黑树的存在就是为了解决二叉查找树的缺陷，因为二叉树在某些情况下会退化为一个线性结构。

![红黑树示意图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181127143319.png)

红黑树是一种自平衡的二叉查找树。红黑树从根到叶子的最长长度不会超过最短路径的2倍

红黑树的特点：
根节点总是黑色的；
每个叶子节点都是黑色的空节点（NIL节点）
每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（即相同的黑色高度）

## 二叉查找

## KMP


## 字典树(Trie)

字典树又称单词查找树。典型应用是统计和排序大量的字符串

- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符都不相同。

## 递归和尾递归


## 布尔过滤器


Bloom Filter是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组Hash算法构成，它将将所有地址经过多个Hash算法，映射到一个bit数组
适合判断一个元素是否在一个集合中，譬如：

- 网页爬虫对URL的去重，避免爬取相同的URL地址；

- 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；

- 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

## 一致性Hash

>增删服务器时，hash不失效，节点变动尽可能少。

- 1.一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环

![Hash圆环](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095451.jpg)

- 2.将存储服务器的ip或者主机名作为关键字进行hash

![主机Hash定位](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095151.jpg)

- 3.将服务器的存储对象进行hash，确定数据在环上的位置，从服务器位置沿环顺着服务器行走，第一台遇到的服务器必定是其定位的服务器

![存储对象](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220955217.jpg)

- 4.发生扩容和缩容时

如果NodeC宕机，其中NodeA，NodeB，NodeC都不会受到影响,只有C对象被重定位到NodeD。
![宕机](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220935521.jpg)
扩容同理。

## Huffman编码

Huffman是一种压缩算法，它本身是一颗带权重的二叉树。

首先统计所有字符出现的次数。
将其放置到优先队列中。
将队列转化为二叉树。（从队列的头中取两个数相加，同时作为两个叶子结点，再把相加的数放到优先队列中。重复以上过程）

## 并查集



## 动态规划

分阶段解决决策问题的数学思想。
>大事化小，小事化了
>动态规划算法也可以说是 '记住求过的解来节省时间'"

动态规划存在三个重要的概念：
`最优子结构`：就算是一个大问题，如何拆解成最优的小问题 F(n)=F(n-1)+F(n-2);
`边界`      : 没得选的时候
`状态转移公式` ：根据最优子结构和边界构建公式

爬楼梯问题：

```java
int getClimbingWays(int n){
    if(n<1){
        return 0;
    }
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2;
    }
    int a=1,b=2,temp=0;
    for(int i=3;i<=n;i++){
        temp=a+b;
        a=b;
        b=temp;
    }

    return temp;
}
```

## 贪心

