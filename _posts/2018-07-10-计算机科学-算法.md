---
layout:     post
title:      java-算法
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
    - 算法
---

如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。

# 算法

>算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀

## 加密解密算法

## 排序算法

排序我们需要关注的性能大致有两个：

1. 平均时间复杂度(最慢的排序方法：n的平方 最快的排序方法：nlg2n)
2. 辅助空间复杂度
3. 排序算法的稳定性

### 为什么要分稳定排序和非稳定排序呢

排序的稳定性 就意味着：具有相同value的数在排序后，相对顺序不变。

- 能保证第二次排序好的 序列保持着第一次的排序顺序。 

第一次排序  a=1 b=2;
第二次排序  a=1 b=1; //虽然a、b的value一致，但是采用稳定排序后，还是能保证上次value值低的在前面

- 具有两个排序关键字的时候，可以让key2的value值相等的同学 还是按照key1的value排序。

### 选择排序

### 冒泡排序

相邻元素进行两两比较，将最大值推动到最右边。重复以上过程。时间复杂度平均O(N^2)最差O(N^2)，空间复杂度O(1)

### 直接插入排序

### 希尔排序

### 堆排序

堆排序使用了最大堆/最小堆，拿数组升序排序来说，需要建立一个最大堆，基于数组实现的二叉堆可以看作一棵完全二叉树，其满足堆中每个父结点它左右两个结点值都大，且堆顶的元素最大。

将堆顶元素和数组最后一个元素交换，最大元素被交换数组最后一个位置，同时从堆中删除原来处于堆顶的最大元素
被交换到堆顶的元素一般会打破堆结构的定义，因此需要进行堆的调整（下沉）。将堆顶的元素和其左右两个结点比较，将三者中的最大的交换到堆顶，然后继续跟踪此结点，循环上述过程，直到他比左右两个结点都大时停止调整，此时堆调整完毕，再次满足堆结构的定义
重复以上两个过程。直到堆中只剩一个元素，此时排序完成
每次调整堆的平均时间为O(lg N)，因此对大小为N的数组排序，时间复杂度最差和平均都 O(N lg N).

### 归并排序

### 快速排序(三数取中)

选择数组中第一个元素作为基准，从左边向右找到第一个大于等于基准的元素，从右边向左找到第一个小于等于基准的元素，交换这两个元素，最后基准左边的元素都小于等于基准，基准右边的元素都大于等于基准。然后固定基准元素，对其左边和右边采取同样的做法。典型的分治思想。时间复杂度平均O(N lgN)最差O(N^2)，基于递归的实现由于用到了系统栈，所以平均情况下空间复杂度为O(lgN)



## 红黑树

红黑树的存在就是为了解决二叉查找树的缺陷，因为二叉树在某些情况下会退化为一个线性结构。

![红黑树示意图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181127143319.png)

红黑树是一种自平衡的二叉查找树。红黑树从根到叶子的最长长度不会超过最短路径的2倍

红黑树的特点：
根节点总是黑色的；
每个叶子节点都是黑色的空节点（NIL节点）
每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（即相同的黑色高度）

## 二叉查找

## 平衡二叉树

平衡二叉树首先是一棵二叉查找树，其次它需要满足其左右两棵子树的高度之差不超过1，且子树也必须是平衡二叉树，换句话说对于平衡二叉树的每个结点，要求其左右子树高度之差都不超过1。

二叉查找树在最坏情况下，退化成链表，查找时间从平均O(lg n)降到O(n),平衡二叉树使树的结构更加平衡，提高了查找的效率；但是由于插入和删除后需要重新恢复树的平衡，所以插入和删除会慢一些。

应用场景比如在HashMap中用到了红黑树（平衡二叉树的特例），数据库索引中的B+树等。

## KMP


## 字典树(Trie)

字典树又称单词查找树。典型应用是统计和排序大量的字符串

- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符都不相同。

## 递归和尾递归


## 布尔过滤器


Bloom Filter是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组Hash算法构成，它将将所有地址经过多个Hash算法，映射到一个bit数组
适合判断一个元素是否在一个集合中，譬如：

- 网页爬虫对URL的去重，避免爬取相同的URL地址；

- 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；

- 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。



## Huffman编码

Huffman是一种压缩算法，它本身是一颗带权重的二叉树。

首先统计所有字符出现的次数。
将其放置到优先队列中。
将队列转化为二叉树。（从队列的头中取两个数相加，同时作为两个叶子结点，再把相加的数放到优先队列中。重复以上过程）

## 并查集

```java
public class UnionFind {
    // id相同的分量是连通的
    private int[] id;
    //连通分量的个数
    private int count;

    public UnionFind(int n) {
        count = n;
        id = new int[n];
        for (int i = 0; i < n; i++) {
            id[i] = i;
        }
    }
	// 所属连通分量的id
    public int find(int p) {
        return id[p];
    }
	// 将和p同一个连通分量的结点全部归到和q一个分量中，即将p所在连通分量与q所在连通分量合并。
	// 反过来也可以
	// if (id[i] == qID) {
	// id[i] = pID;
	// }
    public void union(int p, int q) {
        int pId = find(p);
        int qId = find(q);
        if (pId == qId) return;
        for (int i = 0; i < id.length; i++) {
            if (id[i] == pId) {
                id[i] = qId;
            }
        }
        // 合并后，连通分量减少1
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

还可以有优化的写法，一个连通分量看成是一棵树。同一个连通分量其树的根结点相同。

```java
public class UnionFind {
    private int[] parentTo;
    private int count;

    public UnionFind(int n) {
        count = n;
        parentTo = new int[n];
        for (int i = 0; i < n; i++) {
            parentTo[i] = i;
        }
    }

    public int find(int p) {
        // 向上一直到根结点
        // p = parentTo[p]说明到达树的根结点，返回根结点
        while (p != parentTo[p]) {
            p = parentTo[p];
        }
        return p;
    }
	// 这行的意思就是q所在连通分量和q所在连通分量合并
	// 从树的角度来看，p树的根结点成为了q树根结点的孩子结点
	// 反过来也可以，parentTo[qRoot] = pRoot;
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) return;
        parentTo[pRoot] = qRoot;
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

## 动态规划

分阶段解决决策问题的数学思想。
>大事化小，小事化了
>动态规划算法也可以说是 '记住求过的解来节省时间'"

动态规划存在三个重要的概念：
`最优子结构`：就算是一个大问题，如何拆解成最优的小问题 F(n)=F(n-1)+F(n-2);
`边界`      : 没得选的时候
`状态转移公式` ：根据最优子结构和边界构建公式

爬楼梯问题：

```java
int getClimbingWays(int n){
    if(n<1){
        return 0;
    }
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2;
    }
    int a=1,b=2,temp=0;
    for(int i=3;i<=n;i++){
        temp=a+b;
        a=b;
        b=temp;
    }

    return temp;
}
```

## 贪心

## 回溯

## B+树

B+树是最常见的索引结构。

# 一致性Hash

>增删服务器时，hash不失效，节点变动尽可能少。

- 1.一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环

![Hash圆环](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095451.jpg)

- 2.将存储服务器的ip或者主机名作为关键字进行hash

![主机Hash定位](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095151.jpg)

- 3.将服务器的存储对象进行hash，确定数据在环上的位置，放到哈希环顺时针第一个大于等于该hash值的服务器的结点上。这样从数据的hash位置沿环顺着服务器行走，第一台遇到的服务器必定是其定位的服务器

![存储对象](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220955217.jpg)

- 4.发生扩容和缩容时

如果NodeC宕机，其中NodeA，NodeB，NodeD都不会受到影响,只有C对象被重定位到NodeD。

![宕机](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220935521.jpg)
扩容同理。



## 一致性Hash的特点

- 单调性(Monotonicity)，单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入、删除的时候，应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。
- 平衡性(Balance)：平衡性也就是说负载均衡，是指客户端hash后的请求应该能够分散到不同的服务器上去。一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，

## 虚拟结点

上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。

数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。

解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

## 总结

在分布式系统中一致性hash起着不可忽略的地位，无论是分布式缓存，还是分布式Rpc框架的负载均衡策略都有所使用。
