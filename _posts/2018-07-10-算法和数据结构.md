---
layout:     post
title:      算法和数据结构
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
---

如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。

# 算法

>算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀

## 排序算法

排序我们需要关注的性能大致有两个：

1. 平均时间复杂度(最慢的排序方法：n^2 最快的排序方法：nlg2n)
2. 辅助空间复杂度
3. 排序算法的稳定性

![排序总结](http://5b0988e595225.cdn.sohucs.com/images/20181008/f6cfd54b4a46404bbb5342707064cf18.jpeg)

### 为什么要分稳定排序和非稳定排序呢

排序的稳定性 就意味着：具有相同value的数在排序后，相对顺序不变。

- 能保证第二次排序好的 序列保持着第一次的排序顺序。 

第一次排序  a=1 b=2;
第二次排序  a=1 b=2; //虽然a、b的value一致，但是采用稳定排序后，还是能保证上次value值低的在前面

- 具有两个排序关键字的时候，可以让key2的value值相等的同学 还是按照key1的value排序。



### 交换排序

#### 冒泡排序(稳定)

相邻元素进行两两比较，将最大值推动到最右边。重复以上过程。
时间复杂度平均O(N^2)最差O(N^2)，空间复杂度O(1)

#### **快速排序**

选择数组中第一个元素作为基准，从左边向右找到第一个大于等于基准的元素，从右边向左找到第一个小于等于基准的元素，交换这两个元素，最后基准左边的元素都小于等于基准，基准右边的元素都大于等于基准。然后固定基准元素，对其左边和右边采取同样的做法。典型的分治思想。时间复杂度平均O(N lgN)最差O(N^2)，基于递归的实现由于用到了系统栈，所以平均情况下空间复杂度为O(lgN)

### 插入排序

#### 简单插入排序(稳定，O(n^2) )

插入排序，其实就是斗地主，将原序列分为左侧(已排好的序列)，每次将右侧的第一张牌，从后往前插入到 等于或者大于这张牌的位置上。

#### 希尔排序

希尔排序是简单插入排序的改进版，它与插入排序的不同之处在于，它会优先比较距离较远的元素。
希尔排序又叫缩小增量排序。

### 选择排序

#### 简单选择排序

首先在未排序的序列中选择最小的元素，放到未排列序列的起始位置。重复以上的过程。

无论什么样的数据都是 O(n^2) 的时间复杂度，适合小规模的数据进行排序。

#### 堆排序

堆排序使用了最大堆/最小堆，拿数组升序排序来说，需要建立一个最大堆，基于数组实现的二叉堆可以看作一棵完全二叉树，其满足堆中每个父结点它左右两个结点值都大，且堆顶的元素最大。

将堆顶元素和数组最后一个元素交换，最大元素被交换数组最后一个位置，同时从堆中删除原来处于堆顶的最大元素
被交换到堆顶的元素一般会打破堆结构的定义，因此需要进行堆的调整（下沉）。将堆顶的元素和其左右两个结点比较，将三者中的最大的交换到堆顶，然后继续跟踪此结点，循环上述过程，直到他比左右两个结点都大时停止调整，此时堆调整完毕，再次满足堆结构的定义
重复以上两个过程。直到堆中只剩一个元素，此时排序完成
每次调整堆的平均时间为O(lg N)，因此对大小为N的数组排序，时间复杂度最差和平均都 O(N lg N).



### 归并排序

#### 二路归并排序（稳定）

#### 多路归并排序（稳定）


### 非比较类排序(线性时间 稳定)

#### 基数排序

#### 桶排序

#### 计数排序



























## 加密解密算法

## KMP


## 字典树(Trie)

字典树又称单词查找树。典型应用是统计和排序大量的字符串

- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符都不相同。

## 递归和尾递归


## 布尔过滤器


Bloom Filter是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组Hash算法构成，它将将所有地址经过多个Hash算法，映射到一个bit数组
适合判断一个元素是否在一个集合中，譬如：

- 网页爬虫对URL的去重，避免爬取相同的URL地址；

- 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；

- 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。



## Huffman编码

Huffman是一种压缩算法，它本身是一颗带权重的二叉树。

首先统计所有字符出现的次数。
将其放置到优先队列中。
将队列转化为二叉树。（从队列的头中取两个数相加，同时作为两个叶子结点，再把相加的数放到优先队列中。重复以上过程）

## 并查集

```java
public class UnionFind {
    // id相同的分量是连通的
    private int[] id;
    //连通分量的个数
    private int count;

    public UnionFind(int n) {
        count = n;
        id = new int[n];
        for (int i = 0; i < n; i++) {
            id[i] = i;
        }
    }
	// 所属连通分量的id
    public int find(int p) {
        return id[p];
    }
	// 将和p同一个连通分量的结点全部归到和q一个分量中，即将p所在连通分量与q所在连通分量合并。
	// 反过来也可以
	// if (id[i] == qID) {
	// id[i] = pID;
	// }
    public void union(int p, int q) {
        int pId = find(p);
        int qId = find(q);
        if (pId == qId) return;
        for (int i = 0; i < id.length; i++) {
            if (id[i] == pId) {
                id[i] = qId;
            }
        }
        // 合并后，连通分量减少1
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

还可以有优化的写法，一个连通分量看成是一棵树。同一个连通分量其树的根结点相同。

```java
public class UnionFind {
    private int[] parentTo;
    private int count;

    public UnionFind(int n) {
        count = n;
        parentTo = new int[n];
        for (int i = 0; i < n; i++) {
            parentTo[i] = i;
        }
    }

    public int find(int p) {
        // 向上一直到根结点
        // p = parentTo[p]说明到达树的根结点，返回根结点
        while (p != parentTo[p]) {
            p = parentTo[p];
        }
        return p;
    }
	// 这行的意思就是q所在连通分量和q所在连通分量合并
	// 从树的角度来看，p树的根结点成为了q树根结点的孩子结点
	// 反过来也可以，parentTo[qRoot] = pRoot;
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) return;
        parentTo[pRoot] = qRoot;
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

## 动态规划

分阶段解决决策问题的数学思想。
>大事化小，小事化了
>动态规划算法也可以说是 '记住求过的解来节省时间'"

动态规划存在三个重要的概念：
`最优子结构`：就算是一个大问题，如何拆解成最优的小问题 F(n)=F(n-1)+F(n-2);
`边界`      : 没得选的时候
`状态转移公式` ：根据最优子结构和边界构建公式

爬楼梯问题：

```java
int getClimbingWays(int n){
    if(n<1){
        return 0;
    }
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2;
    }
    int a=1,b=2,temp=0;
    for(int i=3;i<=n;i++){
        temp=a+b;
        a=b;
        b=temp;
    }

    return temp;
}
```

## 贪心

## 回溯

## 一致性Hash

>增删服务器时，hash不失效，节点变动尽可能少。

- 1.一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环

![Hash圆环](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095451.jpg)

- 2.将存储服务器的ip或者主机名作为关键字进行hash

![主机Hash定位](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181022095151.jpg)

- 3.将服务器的存储对象进行hash，确定数据在环上的位置，放到哈希环顺时针第一个大于等于该hash值的服务器的结点上。这样从数据的hash位置沿环顺着服务器行走，第一台遇到的服务器必定是其定位的服务器

![存储对象](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220955217.jpg)

- 4.发生扩容和缩容时

如果NodeC宕机，其中NodeA，NodeB，NodeD都不会受到影响,只有C对象被重定位到NodeD。

![宕机](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201810220935521.jpg)
扩容同理。



## 一致性Hash的特点

- 单调性(Monotonicity)，单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入、删除的时候，应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。
- 平衡性(Balance)：平衡性也就是说负载均衡，是指客户端hash后的请求应该能够分散到不同的服务器上去。一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，

## 虚拟结点

上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。

数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。

解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

## 总结

在分布式系统中一致性hash起着不可忽略的地位，无论是分布式缓存，还是分布式Rpc框架的负载均衡策略都有所使用。






# 数据结构

## stack

先入后出的数据结构。
利用一个数组进行存储
入栈，添加到数组尾部，需要进行扩容检测。
出栈，取出数组尾部元素。

## queue

先入先出的数据结构。
利用一个数组进行存储
入队列，添加到数组尾部，需要考虑扩容检测。
出队列，从数组的头部出队列。



## 树

### 森林

森林其实就是多个树

如何把森林给转化为一个二叉树？

第一步将每个树给变成二叉树：树的每一层，将兄弟联接在一起，然后每个父节点，只保存长子(最左侧的孩子)。同时我们发现每个二叉树的根结点的右孩子为空。

第二步将各个二叉树的根节点依次连接在上一个二叉树的右孩子结点上。


### 二叉查找树

左边的节点都小于根节点，右边的节点都大于根节点。
这个特性给查找带了方便，从树根出发，有一半的节点你都不用访问。
二叉查找树在最坏情况下，退化成链表，查找时间从平均O(lg n)降到O(n),
二叉树的中序遍历就是有序的数列。

插入：空树，首先生成根节点；不是空树就进行查找，找到父节点，然后作为叶子结点插入。
删除：（1）如果是叶子结点，直接删除
    （2）如果只有一个子节点，将子节点平移到被删除元素的位置
    （3）如果有两个子节点，利用中序遍历，获取被删除元素的后一个元素，将其进行互换，此时被删除元素已经是叶子结点，可以直接删除。


### 平衡二叉树

针对二叉查找树退化为链表的情况，平衡二叉树使树的结构更加平衡，提高了查找的效率；但是由于插入和删除后需要重新恢复树的平衡(我们称为旋转操作，分为左旋转和右旋转)，所以插入和删除会慢一些。

首先理解左旋和右旋
**左旋**就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；
![左旋](https://img-blog.csdn.net/20180829143451434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**右旋**就是反过来，将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点。
![左旋](https://img-blog.csdn.net/20180829143509110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQwOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
旋转的目的都是将**节点多的一支出让节点给另一个节点少的一支**。

插入
1.左左，就对结点进行右旋
2.右右，就对结点进行左旋
3.左右，对左结点先左旋变成左左，再右旋
4.右左，对右结点先右旋变成右右，再左旋

删除
（1）当删除的节点是叶子节点，则将节点删除，然后从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，此时到根节点还发现没有失衡，则说此时树是平衡的；如果中间过程发现失衡，则判断属于哪种类型的失衡（左左，左右，右左，右右），然后进行调整
（2）删除的节点只有左子树或只有右子树，这种情况其实就比删除叶子节点的步骤多一步，就是将节点删除，然后把仅有一支的左子树或右子树替代原有结点的位置，后面的步骤就一样了，从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，如果中间过程发现失衡，则根据失衡的类型进行调整。
（3）删除的节点既有左子树又有右子树，这种情况又比上面这种多一步，就是中序遍历，找到待删除节点的前驱或者后驱都行，然后与待删除节点互换位置，然后把待删除的节点删掉，后面的步骤也是一样，判断是否失衡，然后根据失衡类型进行调整。



平衡二叉树首先是一棵`二叉查找树`，其次它需要满足其左右两棵子树的高度之差不超过1，且子树也必须是平衡二叉树，换句话说对于平衡二叉树的每个结点，要求其左右子树高度之差都不超过1。
查询的时间复杂度是 O(logN)
插入复杂度是 O(1) 

应用场景比如在HashMap中用到了红黑树（平衡二叉树的特例），数据库索引中的B+树等。

#### 红黑树

红黑树的存在就是为了解决二叉查找树的缺陷，因为二叉树在某些情况下会退化为一个线性结构。

![红黑树示意图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181127143319.png)

红黑树是一种自平衡的二叉查找树。红黑树从根到叶子的最长长度不会超过最短路径的2倍

红黑树的特点：
根节点总是黑色的；
每个叶子节点都是黑色的空节点（NIL节点）
每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（即相同的黑色高度）

#### B+树

B+树是最常见的索引结构。

结构特点是：

1、是`多叉树了`,而不是二叉树了，同时每个节点可以包含更多的节点，这样做有两个原因,一个是降低树的高度。另外一个是将数据范围变为多个区间，区间越多，数据检索越快。 
2、每个节点不再只是存储一个key了，可以存储多个key； 
3、非叶子节点存储key，叶子节点存储key和数据。 
4、叶子节点两两相连，为顺序查询提供了帮助


使用优势：

1、B+树的非叶子节点只是存储key，占用空间非常小，因此每一层的节点能索引到的数据范围更加的广。换句话说，每次IO操作可以观看更多的数据；
2、叶子节点两两相连，符合磁盘的预读特性。如图三中存储50和55的叶子节点，它有个指针指向了60和62这个叶子节点，那么当我们从磁盘读取50和55对应的数据的时候，由于磁盘的预读特性，会顺便把60和62对应的数据读取出来。这个时候属于顺序读取，而不是磁盘寻道了，加快了速度。
3、支持范围查询，而且部分范围查询非常高效，原因是数据都是存储在叶子节点这一层，并且有指针指向其他叶子节点，这样范围查询只需要遍历叶子节点这一层，无需整棵树遍历。





## 图