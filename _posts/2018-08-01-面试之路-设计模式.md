---
layout:     post
title:      设计模式
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# 设计模式
写出优雅代码的根本在于你对真实世界的合理抽象，就是在于 对面向对象设计思想的理解。
隔离不变与变化



# 原则
设计模式的核心思想是六个基本原则，其那么多的设计模式都是基于这6个原则产生的一系列模板。
而这些原则往往就设计到两个元素：接口，类，以及他们之间的关系。
对于接口：考虑 **分隔原则**
对于类的设计：对于类的本身，需要考虑 **单一职责**；对于类的继承，要考虑 **里氏替换原则** 与 **开闭原则**，减少子类对父类的影响
对于协作关系的设计：在做框架设计时，接口之间发生联系，要考虑 **依赖倒置原则**；当一个类与其他类发生调用关系时，利用中间者来转发调用关系( **迪米特法则** )

- 依赖倒置原则－Dependency Inversion Principle (DIP) 
在高层模块和低层模块之间，引入一个抽象接口层。抽象接口层是对低层模块的抽象，低层模块继承或者实现该抽象接口。
由此，高层模块不依赖低层模块， 低层模块依赖抽象定义
High Level Classes（高层模块） --> Abstraction Layer（抽象接口层） --> Low Level Classes（低层模块）

模块之间的依赖是通过抽象产生,实现类之间不发生直接的依赖关系.
接口或者抽象类不依赖实现类,实现类依赖于接口或者抽象类.



- 里氏替换原则－Liskov Substitution Principle (LSP) 
子类可以替换父类，并出现在父类能够出现的任何地方

- 接口分隔原则－Interface Segregation Principle (ISP) 
最小接口原则，一个接口的某个方法未被使用的话，则说明该接口过胖，应该将其分割为多个功能专一的接口。
这就要求在设计接口的时候，使用多个专门的接口代替单一的胖接口

- 单一职责原则－Single Responsibility Principle (SRP) 
问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。
因此只能让一个类有且仅有一个职责。
换一句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。
>注意:单一职责原则不是只要求我们为类定义一个职责,而是提醒我们在一个类中尽量让类负载少的职责,从而保证对象具有高内聚与细粒度.
应用：分层架构就是单一职责的最佳体现，JavaEE框架就将系统根据职责的内聚给分为了不同层：
```
Presentation:表现层
Business:业务层
persistence: 持久层
Database:数据层
```
- 开闭原则－The Open-Closed Principle (OCP)
可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。
- A.对扩展开放（open）:通过扩展增加功能，实现了功能上的扩展性。
- B.对修改关闭（closed）:模块内部代码不允许修改，该模块修改关闭，保证了功能上的稳定性。

- 迪米特法则－The Law of Demeter (OCP)
对象和对象之间关联应该尽量少，避免千丝万缕的关系。尽量降低类与类之间的耦合，以防止一个类发生改变，另一个依赖的类也受到影响。
1)只同你直接的朋友们通信
2)不要跟陌生人说话
3)每一个软件单位对其他的单位都只有最少的了解,这些了解仅局限于那些与本单位密切相关的软件单位.

# 创造型模式
提供了一种在创建对象的同时，隐藏创建逻辑的方式。大大灵活了创建对象时的灵活性。
## 工厂模式和抽象工厂模式
用于在不同的条件下创建不同的实例，解决接口选择问题。
通过定义接口，让工厂类(将实际创建工作推迟到具体工厂类)实现工厂接口，让调用者自己决定实例化哪一个工厂类，返回的是一个抽象的工厂产品实例。
```java
Facatory aFactory=new AFactory();//AFactory继承接口Facatory，在具体实现的工厂类中创建对象
AWord a=(AWord)aFactory.getWord();//Aword继承Word
```
（1）对于某个产品，调用者清楚地知道应该使用哪个具体的工厂来服务，实例化该具体工厂，生产出具体的产品来；
（2）只是需要一种产品，而不想知道也不需要知道工厂是如何生产出来的，自需要知道具体对应的工厂就行。




## 单例模式(Singleton)
保证一个类仅有一个实例

## 建造者模式(Builder)
将复杂的对象构建与其具体的细节分离，以链式的方法来创造对象。
>类的内部包含一个类的创建静态类，每次用这个静态类再次调用类的构造函数,具体可以参考lombok的Builder实现

## 原型模式(Prototype)
直接创建对象代价较大，采用原型模式，用原型实例指定创建对象的种类，在通过 **拷贝** 原型获取新的对象。
>浅Clone和深clone实现


# 结构性模式
这些设计模式关注类和对象的组合。

## 适配器模式(Adapter)
使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

## 装饰器模式(Decorator)
保持接口，增强性能：修饰类继承被修饰对象的抽象父类，依赖被修饰对象的实例（被修饰对象依赖注入），以实现接口扩展
## 代理模式(Proxy)
为其他对象提供一种代理以控制对这个对象的访问：增加中间层（代理层），代理类与底层实现类实现共同接口，并创建底层实现类对象（底层实现类对象依赖注入代理类），以便向外界提供功能接口

## 外观模式(Facade)
在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。即封装底层实现，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的高层接口

## 桥接模式(Bridge)
两个维度独立变化，依赖方式实现抽象与实现分离：需要一个作为桥接的接口/抽象类，多个角度的实现类依赖注入到抽象类，使它们在抽象层建立一个关联关系

## 过滤器模式(Filter)
使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来

## 组合模式(Composite)
用户对单个对象和组合对象的使用具有一致性的统一接口

## 享元模式(Flyweight)
享元工厂类控制；HashMap实现缓冲池重用现有的同类对象，如果未找到匹配的对象，则创建新对象





# 行为型模式
关注对象之间的通信。
## 策略模式(Strategy)
策略对象依赖注入到context对象，context对象根据它的策略改变而改变它的相关行为(可通过调用内部的策略对象实现相应的具体策略行为

## 模板方法模式(Template)
将这些通用算法抽象出来，在一个抽象类中公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

## 观察者模式(Observer)
一对多的依赖关系，在观察目标类里有一个 ArrayList 存放观察者们。当观察目标对象的状态发生改变，所有依赖于它的观察者都将得到通知，使这些观察者能够自动更新（即使用推送方式）

## 迭代子模式(Iterator)
集合中含有迭代器：分离了集合对象的遍历行为，抽象出一个迭代器类来负责，无须暴露该对象的内部表示

## 责任链模式(Chain of Responsibility)
拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

## 命令模式(Command)
将"行为请求者"与"行为实现者"解耦：调用者依赖命令，命令依赖接收者，调用者Invoker→命令Command→接收者Receiver

## 备忘录模式(Memento)
通过一个备忘录类专门存储对象状态。客户通过备忘录管理类管理备忘录类。

## 状态模式(State)
状态对象依赖注入到context对象，context对象根据它的状态改变而改变它的相关行为(可通过调用内部的状态对象实现相应的具体行为)

## 访问者模式(Visitor)
访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。

## 中介者模式(Mediator)
对象与对象之间存在大量的关联关系，将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散，可以独立地改变它们之间的交互

## 解释器模式
给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子

## 空对象模式
创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。不要为了屏蔽null而使用空对象，应保持用null，远比用非null的值来替代“无值”要好。
