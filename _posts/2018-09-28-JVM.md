---
layout:     post
title:      Java虚拟机
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
    - JVM
---

# JVM

## JVM内存结构

![JVM管理的内存结构图](https://upload-images.jianshu.io/upload_images/2184951-75502fd0f9001ece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/746/format/webp)


![JVM](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181024212730.png)

注意在JAVA8以后，方法区不存在了，方法区中的数据存在了本地内存(包括元数据区和直接内存)的元数据区中和堆中。


### JAVA堆

所有线程共享的一块内存区域，在JVM启动时创建，可以通过 `-Xms` 和 `-Xmx` 设置其大小。

堆用于存放对象实例以及数组。所有的对象实例和数组都要在堆上进行分配。为对象分配内存就是把一块大小确定的内存从堆内存中划分出来。

同时堆也是**垃圾回收的主要区域**，现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
  新生代由S0和S1构成，可通过-Xmn 参数来指定新生代的大小
- 老年代（Old Generation）


#### String pool

全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中

### 方法区

方法区又称为“永久代”，但是java一直在做"去永久代"。

方法区和Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量(final)、静态变量(static)和即时编译器编译后的代码等数据。

运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

对这块区域进行垃圾回收的主要目标是**对常量池的回收和对类的卸载**，但是一般比较难实现。

在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。

方法区存储的内容包括：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。

在 JDK 1.7 1.8 之后，原来永久代的数据(方法区)被分到了堆（1.7）和元数据区（1.8）中。

- 元数据区存储的类的信息，元数据区不再JVM中，而是处于本地内存中。避免了由于大量类的创造而Full  GC的问题，如运行时使用反射、代理。
- 静态变量和常量池等放入堆中。

#### 运行时常量池

运行时常量池是方法区的一部分。

Class 文件的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。由此可知每一个类都会存在于运行时常量池中。

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

1.7之后将常量池分配到了堆内存中。

#### 去永久代

经过1.7 1.8 ，方法区不复存在。

### JAVA栈

线程私有的，每个线程对应一个java栈。
每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），栈帧负责存储`局部变量表`、`操作数栈`、`动态链接`和`方法返回地址`等信息。每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈
过程。
局部变量表存放各种基本数据类型boolean、byte、char、short等。

栈由一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。
每创建一个栈帧压栈，当一个方法执行完毕之后则出栈。

> - 如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 `StackOverflowError`
> - 若线程执行过程中栈帧大小超出虚拟机栈限制，则会抛出 StackOverFlowError。
> - 若虚拟机栈允许动态扩展，但在尝试扩展时内存不足，或者在为一个新线程初始化新的虚拟机栈时申请不到足够的内存，则会抛出 OutOfMemoryError。

![虚拟机栈图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/31.jpg)

每个栈帧里面包括：
1.局部变量表：用来存储方法中的局部变量(非静态变量、函数形参)。当变量为基本类型时，直接存储值，当变量为引用类型时，存储指向具体对象的引用。
2.操作数栈：一个用于操作数的栈结构
3.指向运行时常量池的引用：程序执行时，可能会用到常量池中的引用。
4.方法返回地址：存储方法执行完成后的返回地址。


### 指令计数器

指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码指令的地址，可以看作当前线程所执行的字节码的**行号指示器**。
分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成。
如果线程执行的是native方法，这个计数器则为空。

### 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。

`本地方法`：一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

那么我们为什么要使用本地方法呢？

- 与java环境之外的东西进行交互
- 与操作系统进行交互

### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。


## 垃圾回收

垃圾回收，涉及到三件事情：

- 哪种内存需要回收
- 什么时候回收
- 怎么回收

### 回收的类型

垃圾收集主要是针对`堆`和`方法区`进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

### 判断一个对象是否可回收
1.引用计数算法
2.可达性分析算法
3.方法区的回收，主要是对常量池的回收和对类的卸载。
1. finalize()

#### 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

1.强引用
被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

2.软引用
被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```
3.弱引用
被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

4.虚引用
又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。
```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```




### 如何回收

#### 标记-清除

#### 标记-整理

#### 复制

#### 分代回收

当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。

Hotspot VM将内存划分为不同的物理区，就是“分代”思想的体现。如图所示，JVM内存主要由新生代、老年代、永久代构成。

![分代](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/ab15459b.png)

1.新生代，大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。
新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。

2.老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。

3.永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。(在1.8后，就不存在永久代了)

### 常见的垃圾回收器

不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：

- 串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。
- 并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。
- 吞吐量优先（Parallel Scavenge）收集器，侧重于吞吐量的控制。
- 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。

## 内存分配和回收策略

### Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
  对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。
- Major GC：清理老年代
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。
  
  
### 内存分配策略

1.对象优先在Eden分配，大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
2.大对象直接进入老年代，大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
3.长期存活的对象进入老年代，为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。
4.动态对象年龄判定，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
1. 空间分配担保，在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

# 类的加载过程

类在运行期间第一次使用时是动态加载的，不是一次性加载所有类。一次性全部加载，会占用很多的内存。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 七个阶段。

其中类的加载过程包括：`加载、验证、准备、解析、初始化` 五个阶段。

在这五个阶段中，`加载、验证、准备和初始化`这四个阶段发生的顺序是确定的，而解析的阶段则不确定。它在某些情况下，可以晚于初始化进行，这是为了支持java语言的运行时绑定。

>静态绑定：编译时绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。
>动态绑定：即运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是动态绑定的。

## 加载

1.通过类名来获取其定义的二进制字节流。
2.将字节流所代表的静态存储结构转化为`方法区`的运行时数据结构。
>方法区是是每个线程共享的，用于存储：被虚拟机加载的类信息、常量、静态变量。
3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区中的这些数据的入口。

其中二进制字节流可以从以下的方式获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

### 类的加载机制

jvm是如何把数据加载到内存中的呢？是通过`类加载器`。

Classloader是用来加载class的，它负责将Class的字节码形式转换为内存形式的Class对象。字节码来自于磁盘中的.class文件，来自jar包中的class文件，也可以来自远程服务器提供的字节流，字节码的本质是一个字节数组。(byte[]->class)

类加载器具有延迟加载的特点，及JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。

>比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载


java提供了这么几种类加载器，同时这些加载器之间存在继承关系。

- 启动类加载器(Bootstrap ClassLoader),复杂加载JVM运行时的核心类，常见的库包括`java.util.*,java.io.*,java.nio.*,java.lang.*`等。这些类通常位于`JDK\jre\lib\rt.jar`文件中，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库。启动类加载器是无法被Java程序直接引用的。

- 扩展类加载器(Extenion ClassLoader)，负责加载JVM扩展类，比如`Swing,内置js引擎，xml解析器`。这些类存放在`JDK\jre\lib\ext`目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。开发者可以直接使用扩展类加载器。

- 应用程序类加载器(Application ClassLoader),它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载.

- 自定义类加载器

那些位于网络上静态文件服务器提供的 jar 包和 class文件，jdk 内置了一个 URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用 URLClassLoader 来加载远程类库了。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。


### 双亲委派模式

如果一个类加载器得到了类的加载请求，首先他不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

![双亲委派模式图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181030104642.png)

这就是我们说得`双亲委派模式`，那么这种模式的好处是什么呢？

>同一个类的定义：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。

Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了`Object类在程序中的各种类加载器中都是同一个类`。

## 验证

验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。
文件格式的验证、元数据的验证、字节码验证和符号引用验证。

- 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
- 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
- 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在`方法区`中分配。

这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

当然如果用final形容的变量，在编译时Javac将会为value生成ConstantValue属性。

```java
public static int value = 3；//初始值为0
public static final int value = 3；//初始值为3
```

在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。

## 解析

解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。这就是我们当年学编译原理的“链接”阶段。

>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

## 初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程，其中包含编译器自动收集的**类变量的赋值(非final)**和静态语句块中的语句。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

错误：

```java
public class Test {
    static {
        i = 0;                
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

正确：

```java
public class Test {
    static int i=1;//ida提示赋值是多余的，但是不会报错
    static {
        i=0;
        System.out.println(i);
    }
}
```


## 总结

整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

# java值传递和引用传递

数据在内存中的存储，是依赖于数据类型来划定存储形式和存储位置的。那么，java的数据类型有什么呢？

1.基本数据类型：
    4种整数类型：byte，short，int，long
    2种浮点类型:float 、double
    1种字符类型：char
    1中布尔类型：boolean

2.引用类型：引用存放着实际内容所在地址的地址值的一种数据形式。
    类
    接口
    数组

有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得了解JVM的内存划分以及每部分的职能。

![Java程序执行内存图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181026144814.jpg)

从上面的程序运行图，我们可以看出JVM在内存分配时，涉及到这些地方：

- 堆
- 栈
- 静态方法区
- 常量区

java当中只存在值传递，不存在引用传递。都是一种副本传递

如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。

如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。







