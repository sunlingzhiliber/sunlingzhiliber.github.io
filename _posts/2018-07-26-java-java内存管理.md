---
title: ""
categories:
  - Java
tags:
  - java内存管理
---


 # 内存模型
 计算机在执行程序时，指令的执行实在CPU中执行的，而数据是存储在内存中的。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

 # CPU缓存
 CPU缓存的出现是为了解决 **CPU运算速度和内存读写速度不一致的矛盾** 
 CPU大多数情况下不会直接读取内存，而是会访问CPU缓存。它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。
 当然我们要知道这种机制实现的基础是：我们将要访问的数据应该是相邻的这一认识。

 # CPU缓存冲突问题
 多核CPU处理同一个数据时，必然会发生不一致问题。因此CPU制作商制定了一个规则：~~当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效~~。

# Java内存模型
在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。

　　Java内存模型规定所有的变量都是存在主存当中（物理内存），每个线程都有自己的工作内存（CPU高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。


