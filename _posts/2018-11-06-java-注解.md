---
layout:     post
title:      java-注解
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
    - Annotation
---

java注解和普通的修饰符(public、static、void等)的使用方式没有多大的区别。

# 基本语法

```java
//声明Test注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
}
```

@Target用来约束注解可以应用的地方，基本上你能想到的所有地方都可以使用注解。

@Rentention用来约束注解的生命周期，分别有三个值，分别是源码级别、类文件级别和运行时注解，其含义如下：

SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里），如Lombok的@Data注解

CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等

RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。

注解内部也可以定义其他元素，方便处理器使用。支持的元素类型包括:

- 所有的基础类型(int,float,boolean,byte,double,char,long,short)
- String
- Class
- enum
- Annotation
- 上述类型的数组

针对内部元素，我们必须有确定的值。也就是说。元素必须有default值，或者在使用注解时赋值。

# 注解与反射机制

Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。
同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口。

# SpringBoot注解大全

@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。

@Configuration 等同于spring的XML配置文件；可结合@Bean使用

@EnableAutoConfiguration 自动配置。

@ComponentScan 组件扫描，可自动发现和装配一些Bean。

@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。

@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。

@Autowired自动导入。

@PathVariable获取参数。

@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的URL请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。
用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：
   params:指定request中必须包含某些参数值是，才让该方法处理。
   headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。
   value:指定请求的实际地址，指定的地址可以是URI Template 模式
   method:指定请求的method类型， GET、POST、PUT、DELETE等
   consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;
   produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回

@RequestParam：用在方法的参数前面。
String a =request.getParameter(“a”)。

@JsonBackReference解决嵌套外链问题。

@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。


@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。

@Import：用来导入其他配置类。

@ImportResource：用来加载xml配置文件。

@Autowired：自动导入依赖的bean

@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者。

```java
@Autowired 
@Qualifier(value = “demoInfoService”) 
private DemoInfoService demoInfoService;
```

@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。

@Service：一般用于修饰service层的组件

@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。

@Bean：用@Bean标注方法等价于XML中配置的bean。

@Value：注入Spring boot application.properties配置的属性的值。

@Inject：等价于默认的@Autowired，只是没有required属性；

@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。

@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。

--------------------JPA-------------------------
@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略

@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。

@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。

@Column：如果字段名与列名相同，则可以省略。

@Id：表示该属性为主键。

@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。

@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。

@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式

@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。

@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。

@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。

--------------------Mongodb-------------------------

@Document 标明该类映射的集合名；类似@Entity注解

@Id  主键 不可重复，自动维护

@Indexed(Unique=true)  索引，加索引后以该字段为条件检索将大大提高速度。
对数组进行索引，MongoDB会索引这个数组中的每一个元素。
对整个Document进行索引，排序是预定义的按插入BSON数据的先后升序排列。
对关联的对象的字段进行索引，譬如User对关联的address.city进行索引

@CompoundIndex ： 联合索引 加复合索引后通过复合索引字段查询将大大提高速度。

```java
@Document(collection="system_user") 
// userName和age将作为复合索引
// 数字参数指定索引的方向，1为正序，-1为倒序
@CompoundIndexes({
    @CompoundIndex(name = "userName_age_idx", def = "{'userName': 1, 'age': -1}")
})
public class User{
    @Id
    private String id;
    private String userName;
    private String age;
    
}
```

@Field ： 属性 能够设置参数的key值

@Transient： 属性 忽略记录到数据库中

@DBRef :关联另一个document对象。类似于mysql的表关联，但并不一样，mongo不会做级联的操作。 
```java
public class School{
    @Id
    private String id;
    private String name;
    @DBRef
    private List<Student> students;
}
```

比如我们建立三个学生，然后一个学校，将学生赋值给学生list，执行学校的插入操作
**在不加@DBRef的情况下**
学校的list会直接存储学生的全部信息，当然也不会为学生建Document。(不同于sql的级联存储)

**在使用@DBRef的情况下**
学校的list中不会直接存储所有属性，而只是存储了学生的id和namespace,注意这里也不会为学生创建Document。
不会级联保存，会导致exception，因此需要单独处理关联的对象

```java
org.springframework.data.mapping.MappingException: Cannot create a reference to an object with a NULL id.
```


同理在删除学校时，关联的学生并不会删除。同理删除学生，学校也不会更改。

从这里来看，这个@DBRef是比较鸡肋的，甚至会以SQL的思维误导大家。

使用情形大致是为了避免单个document过大，而模拟sql外键的作用。