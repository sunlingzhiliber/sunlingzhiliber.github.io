---
layout:     post
title:      网站开发经历
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - Web
    - RPC
    - Rest
    - 微服务
---

网站开发经历
<!-- TOC -->

- [1. 应用发展过程](#1-应用发展过程)
- [2. RPC原理](#2-rpc原理)

<!-- /TOC -->
# 1. 应用发展过程

1.单一应用架构（Monoliths）

当网站流量很小的时候，我们只需要一个应用，就可以把所有的功能部署在一点，减少了部署的成本。此时，用于简化数据库CURD的数据访问框架，ORM(对象关系映射)是关键。

这样的代码存在这样的问题：每个功能严密耦合，无法满足高并发的业务需求。

2.垂直应用架构(纵向分解的思路)

随着我们系统业务的增多、访问量的增大，我们发现单机运行此系统已无法应付压力，因此我们将系统业务拆分为`互不关联的系统`，分别部署在各自的机器上，以划清逻辑并减少压力。但是系统与系统之间可以通过http 或 restful 的方式进行服务的调用。

![MVC系统](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126171349.png)

此时，在单个系统中用于加速开发的MVC框架是关键(分层的思想)。在单个系统中有各自的前端、后端和数据存储。在模块之间共享代码是严令禁止的。

3.分布式应用架构(RPC)

对于垂直子模块而言，它本身仍然属于一个完整的应用。
有一个单机应用所拥有的所有特点：web 层，服务层，持久层，
而且为了解决子应用与子应用之间的依赖，除了需要常规的 web 层外，通常还需要一层与 web 层同级的 api　层用于向依赖它的其他子应用提供服务，在功能上 web 层与 api 层最大的区别就是 web 包含返回页面，而 api 返回数据，两层之间有很多可以共用的逻辑，这就造成了代码的重复，
同时，由于 api 层对外提供服务，其他子应用由于业务需求需要新的服务时，提供服务的子应用不得不进行重新部署，即使它本应用的业务并为发生实质上的改变，这就造成了耦合。

![系统交互](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126190227.png)

为了解决这种情况，分布式服务架构便出现了，它将已经进行了垂直切分的应用再进行水平切分，将 web 层与服务层完全隔离开了，web 层单独成一个应用面向用户，服务层专职提供服务。

![水平切分](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126190335.png)

这种架构中，请求到达应用后，对请求的处理会被分布于多个模块中，然后每一模块产生的结果汇总成一个响应，发送回请求者。

此时，在不同模块之间的通讯联系手段，提高业务复用及整合的 RPC(Remote Procedure Call，远程过程调用) 是关键。
[RPC](#rpc原理)的目标是：使本程序调用其他远程主机上的函数，好像调用本程序内的函数一样简单，并且屏蔽了编程语言、操作系统的差异性。

RPC的调用有两种实现：
基于HTTP的RPC ，具有使用灵活，实现便捷（多种开源Web服务器支持），天生支持异构平台的调用。
基于TCP的RPC，效率更高，但实现起来更加复杂，由于协议不同和标准不同，难以跨平台。

4.流动计算架构(SOA)

(1) 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。

此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。

(2) 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。

这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。

(3) 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？

为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。

其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。

这里的一系列都需要一个调度中心来对服务进行管控和监管。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。

服务导向式架构（SOA）是集成多个较大组件（一般是应用）的一种机制，它们将整体构成一个彼此协作的套件。

这里简单的介绍一下dubbo：
![Dubbo架构图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126173006.png)

Dubbo是一个阿里巴巴开源出来的一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。其核心部分包含:

远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。

集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

常见的使用模式是：Dubbo实现服务，Zookepper进行服务注册。

5.微服务

在微服务架构中，业务逻辑被拆分成一系列小而松散耦合的分布式组件，共同构成了较大的应用。每个组件都被称为微服务，而每个微服务都在整体架构中执行着单独的任务，或负责单独的功能。每个微服务可能会被一个或多个其他微服务调用，以执行较大应用需要完成的具体任务；

使用微服务架构还提供这样一种机制：增加新加入开发者的生产效率，并减少新功能的推广时长。每个微服务的代码库与相关工具集都很有限；开发者无需再去了解庞大而复杂的系统，只需理解自己所做的那部分微服务相关子集，便能贡献生产力。由于无需考虑应用的现有部分使用了什么语言或工具集，或者较大应用的其他开发者是否了解这些语言和工具，只需使用当前任务最趁手的工具，因此微服务开发起来非常迅速。

6.消息队列

主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。

# RPC原理

由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。

如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行service.sayHello("test")时，实质上调用的是远端的服务。这种方式其实就是RPC（Remote Procedure Call Protocol）

## 如何调用远程服务

要实现透明的网络通信细节，我们自然要对通信细节进行封装。

![调用流程](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126192508.png)

1）服务消费方（client）调用以本地调用方式调用服务；
2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3）client stub找到服务地址，并将消息发送到服务端；
4）server stub收到消息后进行解码；
5）server stub根据解码结果调用本地的服务；
6）本地服务执行并将结果返回给server stub；
7）server stub将返回结果打包成消息并发送至消费方；
8）client stub接收到消息，并进行解码；
9）服务消费方得到最终结果。

RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

## 如何对消息进行编码和解码

客户端和服务端相互通信的消息结构如何在网络中传输呢？我们考虑到了序列化的操作。为什么需要序列化？转换为二进制串后才好进行网络传输嘛！为什么需要反序列化？将二进制转换为对象才好进行后续处理！

现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：1）通用性，比如是否能支持Map等复杂的数据结构；2）性能，包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；3）可扩展性，对互联网公司而言，业务变化快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，删除老的字段，而不影响老的服务，这将大大提供系统的健壮性

## 通信

消息数据结构被序列化为二进制串后，下一步就要进行网络通信了。目前有两种IO通信模型：1）BIO；2）NIO。一般RPC框架需要支持这两种IO模型。

常见的是基于Netty-IO通信框架

## 如何发布自己的服务呢？

如何让别人使用我们的服务呢？有同学说很简单嘛，告诉使用者服务的IP以及端口就可以了啊。确实是这样，这里问题的关键在于是自动告知还是人肉告知。

有没有一种方法能实现自动告知，即机器的增添、剔除对调用方透明，调用者不再需要写死服务提供方地址？当然可以，现如今zookeeper被广泛用于实现服务自动注册与发现功能！

![zookeeper](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126192901.png)

# 微服务和SOA的区别

![区别](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126210718.png)

`SOA`可以看成一个大容器，在这个大容器里面，一个应用（application）的所有组件（components）紧密组装在一起。

`微服务`则是把一个应用（application）进一步拆分成了多个小型自治的服务（services）集合

---------------------

我们这里以购物网站为例子：

使用SOA，我们会将购物网站拆分成主要的业务逻辑组，并将每个部分作为独立的应用开发，最后集成到一起。

使用微服务，会将购物网站切分成较小的任务导向服务。他不在是一个购物网站的应用，而各种服务。

![比较](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126210655.png)

微服务与SOA有很多相同之处。两者都属于典型的、包含松耦合分布式组件的系统结构。但是两种架构背后的意图是不同的：SOA尝试将应用集成，一般采用中央管理模式来确保各应用能够交互运作。微服务尝试部署新功能，快速有效地扩展开发团队。它着重于分散管理、代码再利用与自动化执行。

| 架构     | SOA              | 微服务                   |
|----------|------------------|--------------------------|
| 组建大小 | 大块业务逻辑     | 单独任务或小块业务逻辑   |
| 耦合     | 通常松耦合       | 总是松耦合               |
| 公司架构 | 大型公司         | 小型、专注功能交叉的团队 |
| 管理     | 中央管理         | 分散管理                 |
| 目标     | 应用能够交互操作 | 快速扩展开发团队         |