---
layout:     post
title:      java-基础编程
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# hashcode()和equals()
1. `equals()` 
用于判断两个对象的地址是否相等（即  是否是同一个对象 if(this==obj) ），调用默认的`equals()`方法相当于使用`==`方法，判断内存地址，因此我们经常需要重写父类的equals()函数：如若两个对象的内容相等，`equals()`方法则返回true，反之返回false。
诸如`String,Interger,Date`等类的`equals`函数就被进行了覆盖。

我们注意在重写equals时，必须满足以下的要求：（其实我们在重写equals时，应当同时覆盖hashCode，以保证元素的唯一性）
```
1. 对称性：如果x.equals(y)返回是"true"，那么y.equals(x)也应该返回是"true"。
2. 反射性：x.equals(x)必须返回是"true"。
3. 类推性：如果x.equals(y)返回是"true"，而且y.equals(z)返回是"true"，那么z.equals(x)也应该返回是"true"。
4. 一致性：如果x.equals(y)返回是"true"，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是"true"。
5. 非空性，x.equals(null)，永远返回是"false"；x.equals(和x不同类型的对象)永远返回是"false"。
```

2. `hashCode()`
用于获取对象在哈希表中的索引位置， 虽然，每个Java类都包含hashCode()函数。但是，仅仅当创建并某个“HashTable”（HashMap，Hashtable，HashSet）时，该类的hashCode()才有用。
也就是说：**hashCode() 在散列表中才有用，在其它情况（线性表）下没用**。
在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。前提是散列表中
  - 如果两个对象相等，那么它们的hashCode()值一定要相同；
  - 如果两个对象hashCode()相等，它们并不一定equals()相等。

3. 两者的关系
当不创建”类的散列表“的时候，hashCode()和equals()没有任何联系。
当创建”类的散列表“的时候，他们是由关系的：
  - 1)如果两个对象equals()相等，那么它们的hashCode()值一定要相同；
  - 2)如果两个对象hashCode()相等，它们并不一定equals()相等。
    因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。
  - 3)如果两个对象hashCode()不相等，它们一定equals()不相等。
    因此在往散列集合中添加元素时，可以先比较hashCode(),相等后再比较equals(),提高比较的效率



# 泛型、异常、反射
 1. 异常和错误
 >异常实现程序的健壮性
 Java标准库中建了一些通用的异常，这些类都以Throwable为顶层父类。
 Throwable又派生出Error类和Exception类。根据类的派生关系，我们可以对Throwable进行分类：
 Error:代表了JVM本身的错误，这些错误不能被程序员通过代码进行处理，Error很少出现且难以处理。
 Exception：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。
 ![](/assets/images/something/error.png)

 另外我们可以根据JavaC对于异常的处理要求，将Throwable分为另类：
 非检查异常：Error以及RuntimeException，这些异常，在javac编译时，并不会提示与发现这些异常。当然我们也不建议通过异常不获取去处理这些错误。因为这些错误往往是代码本身就存在问题，我们应该修改代码以避免错误。
 检查异常：JavaC强制要求为此类异常做异常捕获与处理，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。

那么我们如何对异常进行处理呢？有两种方法
一种方法是利用try..catch..finally进行处理，另一种是throws异常声明 交给函数调用者caller去解决
```java
public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{ 
     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。
}

public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{ 
     try {

     }catch(ExceptionType1 ex1){
         //dosomething
     }catch(ExceptionType2 ex2){
         //dosomething
     }finally{
         //清理工作
     }
}

```


 2. 泛型
 >本质是，将类型由原来的具体 变成 类型参数化 ，提高代码的重用性，
 泛型的形式包括
 <T> <E> <K> <V> <T extends Number> <T super Number>  用于声明 类（类名之后），方法（方法返回值之前），
 <?> <? extends Number>(Number的子类都可以)  <? super Number> 通配符用于参数
 在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。


 泛型只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。
 
 **对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**
 同时是没有 ~~泛型数组~~ 这一定义,但是用通配符是可以的
```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.
List<String>[] lsa = new List<String>[10]; //error
```

 3. 反射
 >反射是框架设计的灵魂
Java的反射机制是在运行状态中，你都可以获取任意一个类，任意一个对象，并对它进行操作。

```java
Class stuClass3 = Class.forName("fanshe.Student");
```




# foreach循环的原理及注意点
只要想使用foreach循环遍历集合时，必须正确地实现Iterable接口，以此进行集合的遍历
```java
int a[]={1,2,3,4,5,6,7,8};
for (var i : a) {
    System.out.println(i);
}

List<String> b=new ArrayList<>();//List实现了Iterable接口
b.add("1");
b.add("2");
for (var s : b) {
    System.out.println(s);
}
```

注意我们在foreach 集合时，是不能 **删除/添加/修改** 集合内容，“只读”操作
>forEach() 与foreach是不用，forEach()是通过函数式接口 Consumer<T>实现的 可以使用lambda表达式



# static final 等关键字的作用
`static` 静态的，可以用来修饰 方法，类以及变量。同时也可以利用static代码块来优化程序性能。
1) 静态方法 ，静态方法不依赖对象就可以直接使用，当然因为不依赖对象，在其内部就无法使用类的非静态变量和非静态方法。
2) 静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，会在类的初次加载时初始化。
3) 静态代码块，通过控制代码运行顺序，以优化程序性能。
顺序：静态变量->静态代码块->构造代码块->构造方法(注意继承时，父类优先)
```java
class Work {
    private static int start;
    private static int end;
    private String name;
    static {//静态代码块，只会执行一次，常用于类 属性的初始化(只用于静态变量)
        start=1;
        end=2;
    }
    {//构造代码块，每次 声明对象时调用， 优先于构造函数执行 
        name="Type";
    }

    public Work(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```
------------------

`final` 无法改变的，你将无法改变这个引用，它可以用于修饰变量、方法和类。经过final修饰，JVM会对其进行优化。
1) final变量 final总是和static一起使用，用来声明一个 **只读常量** 。必须在声明的时候初始化或者在构造函数中初始化。final变量应该大写。
对于集合对象为final类型时，我们可以向其添加，删除以及修改其内容， 但是不能改变它的引用
```java
public class Main {
    private static final List list = new ArrayList();
    public static void main(String[] args) throws IOException {
        list.add("String");
        list.forEach(System.out::println);
        list=null; //not valid
    }
}
```

2) final方法 fianl方法标志着不可被子类的发方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。
3) final类   final类的功能是完整的，它不能被继承。java中具有很多final类，比如String、Interger等。


# 序列化、反序列化和transient
序列化：将一个对象转成一串二进制表示的字节数组，通过保存或者转移这些字节数据来达到持久化的目的。
反序列化：将字节数组重新构建为对象。

那我们做序列化和反序列化是为了什么呢？ 为了 **持久化**。持久化，就是我们将内存中的对象给 ~~持久~~ 的存储起来。这里我们就有个疑问？我们不用使用序列化 也可以将对象存储到文件中，那么为什么需要序列化呢?

- 存储到数据库\文件中
- 网络传输
- RMI(remote method invocation,它是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上)传输对象
- 读取JavaBean状态


当一个类实现了接口Serilizable，这个对象就可以实现序列化和反序列化。
同时这个类我们并不想它的所有字段都进行序列化，由此我们可以用transient来修饰变量。

注意transient要和接口java.io.Serializable一起使用，





# volatile
volatile关键字的作用是保证变量在多线程之间的可见性，他也可以保证有序性。它是java并发开发的核心基础。
1. valatile的两层语义
   一旦一个共享变量被volatile修饰后，
   1) 不同线程对这个变量进行操作后，都会立即可见。（修改后，会立即写入主存，会使其他线程的缓存无效）
   2) 禁止进行指令重排序。（重排序时，在volatile变量之前的操作已经完成，在volatile之后的没有进行）

2. 实现
有valatile修饰的变量，在其汇编代码之前可以看到 lock，该lock（内存屏障）会触发两件事
  - 将当前处理器缓存行的数据立即写回到系统内存。(一般是写到缓存后，是不确定什么时候会写到内存)
  - 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。
  - 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

3. 使用条件
  对变量的写操作不依赖于当前值
  该变量没有包含在具有其他变量的不变式中

4. 应用场景
  状态标记量，Double Check








# string的 intern方法的内部细节
检测字符串常量池是否存在对应字符串，
若存在，则返回池中的字符串，若不存在，该方法会添加原字符串在存储堆中的引用到字符串池，再返回该引用。
```java
String a=new String("test");//指向堆  创建了两个对象，常量池中的”test”和堆中对象。
String s=a.intern();//指向常量池
System.out.println(s==a);//false


String str2 = new String("str")+new String("01");//str 01 都会进入常量池，字符串的+ 是通过StringBuilder append 后 再 ToString（）的 ，str01只会在堆中
str2.intern();//此时常量池不存在str01 因此intern之后，添加原字符串在存储堆中的引用到字符串池，再返回该引用。
String str1 = "str01";//str01在常量池中的引用 是指向堆中的字符串“str01”
System.out.println(str2==str1);//true
```

# String的equals()和hashCode()
>这里我们特别注意字符串的equals()的调用，String::equals 是覆盖了Object的equals函数

只要字符串内容相同，字符串则equals()相等

>这里我们特别注意字符串的hashcode的调用，String::hashCode 是覆盖了Object的hashCode函数
```java
    public static int hashCode(byte[] value) {
        int h = 0;
        for (byte v : value) {
            h = 31 * h + (v & 0xff);
        }
        return h;
    }
```
从代码可以看出，只要他们value一致，他们的hashCode()就是一致的。但是他们的hashCode()一致，不能说明他们value一致，比如字符串"Aa"和"BB"。(在理想情况下：**为不同的对象产生不相等的hashCode**，但是这种理想情形是非常困难的，因为hachCode的生成是非随机生成的，它有一定的规律，同时这个规律就是每个hash算法的优势所在。))

特点： 相同前缀的字符串所生成的hash值是相邻的


# 字符串常量池
字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。
![常量池情形](/assets/images/something/string.png)

JVM为了减少字符串对象的重复创建，维护了一段特别的内存称为字符串常量池，每次通过字面量形式创建字符串时，会首先取字符串常量池中读取是否已存在，已存在则将引用返回。

我们要首先认识到String 是不可变的，是final修饰的。因此多个变量可以共享同一个对象，由此才有字符串常量池的说法。同时因为是final不可变类型，也出现了有效防止字符串被修改的情况


当然String对象的不可变设计，可以在Hash类型进行缓存hashCode时，执行效率提升。

```java
final String h="sunlingzhi";
String s="sunlingzhi";//指向常量池
String y="sunlingzhi";
System.out.println(s==y);//true 
String z=new String("sunlingzhi");//指向堆空间
System.out.println(s==z);//false  s和z不是同一个对象


String v=s+y; //stringBuilder.append() 非final字段在运行期进行赋值处理 指向堆

String a=h+"sunlingzhi"//常量池  final字段编译期会进行常量替换 指向常量池


//额外注意hashCode和equals函数
//s、y、z  他们三者两两的以上函数 都为true
```
# KMP算法-字符串匹配
1. 求next[]
2. 匹配


# hash冲突：拉链法
我们先来看看HashMap  put时的情形
```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key) {
    int h;
    //获取key的hashCode(),
    //获取hashCode()16个高位 进行异或操作
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

put方法的实现是根据key的hashCode进行hash运算，得到值hash；
根据hash值去确定数组的位置，index=hash& (table.length.-1)（效率高）
length是2的次方
说明：
```
  x % 2的n次方= x & (2的n次方-1);
  HashMap的数组长度，总是2的n次方
  因此 位桶的位置 index= hash & (length -1) //等价于 hash % length，采用位运算效率高
```

>Java中每个位桶都是采用的链表+红黑树来实现的。
![HashMap](/assets/images/something/hashMap.png)
在我们明白HashMap是如何进行put之后，我们来讨论什么是哈希冲突？
其实就是再采用哈希函数对输入域进行映射到哈希表的时候，因为哈希表的位桶的数目远小于输入域的关键字的个数，所以，对于输入域的关键字来说，很可能会产生这样一种情况，也就是，不同关键字会映射到同一个位桶中的情况。
Java中是使用拉链式来解决冲突的，
```java
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        // table是否为空或者length等于0, 如果是则调用resize方法进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else { // table表该索引位置不为空
            Node<K,V> e; K k;
            if (p.hash == hash &&// 判断p节点的hash值和key值是否跟传入的hash值和key值相等
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;// 如果相等, 则p节点即为要查找的目标节点，赋值给e
            else if (p instanceof TreeNode) //添加红黑树
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {// 走到这代表p节点为普通链表节点
                for (int binCount = 0; ; ++binCount) {// 遍历此链表, binCount用于统计节点数
                    if ((e = p.next) == null) {// p.next为空代表不存在目标节点则新增一个节点插入链表尾部
                        p.next = newNode(hash, key, value, null);

                         // 计算节点是否超过 TREEIFY_THRESHOLD（8）个, 减一是因为循环是从p节点的下一个节点开始的
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);// 如果超过8个，调用treeifyBin方法将该链表转换为红黑树
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e; // 将p指向下一个节点
                }
            }
            // e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);// 用于LinkedHashMap
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)  // 插入节点后超过阈值则进行扩容
            resize();
        afterNodeInsertion(evict);  // 用于LinkedHashMap
        return null;
    }
```

# 如何创建线程
java 1.5之前，创建启动一个线程可以 继承Thread类，也可以 实现Runnable接口，但是这两种凡是都无法获取执行任务之后的执行结果。
Thread类只支持Runnable
```java
public interface Runnable {//返回值为void，所以无法返回结果
    public abstract void run();
}
```
1.5之后，java提供了Callable和Future接口，实现Callable接口，使用Future结果就可以获取线程运行结果。


# Callable Future 和 FutureTask

`Callable` 接口和 `Runnable` 接口很相似，但是其call方法有返回值，所以可以获取线程执行的返回值。
Thread类不支持Callable，因此需要使用ExecuteService来执行。
```java
public interface Callable<V> {
    V call() throws Exception;
}
```

`Future`就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。
`Future` 接口 声明了5个方法，分别是：
1) cancel()      用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。
2) isCancelled() 表示任务是否被取消成功。
3) isDone()      表示任务是否完成。
4) get()         获取任务的执行结果，这个方法会产生 **阻塞** ，一直等到任务执行完毕才返回。
5) get(long timeout,TimeUnit unit)   获取任务执行结果，如果在timeout时间内没有获取到结果，就直接返回null。
>Future可以判断任务是否完成，能够中断任务，能够获取任务执行结果。但是future只是接口，是无法直接用来创建对象使用的，因此有了FutureTask。


`FutureTask`  实现了RunnableFuture<V>接口->RunnableFuture<V>接口实现了Future和Runnable接口
1)FutureTask是Future接口的一个唯一实现类。 
2)FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可以提交给ExecuteService(->Callable)来执行。
```java
public interface ExecutorService extends Executor {
    <T> Future<T> submit(Callable<T> task);//常用
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);//常用

    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);
}
``` 
3)FutureTask实现了Futrue可以直接通过get()函数获取执行结果，该函数会阻塞，直到结果返回。

另外它还可以包装Runnable和Callable，由构造函数注入
```java
 public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```
我们能看出，Runnable最后也会被转换为Callable执行，即FutureTask最终都是执行Callable类型的任务。

这里我们将介绍使用流程：
1.创建Runnable实现类对象或者Callable实现类对象。
2.创建FutureTash对象，将Runnable实现类对象或者Callable实现类对象作为参数、
3.创建Thread `Thread thread=new Thread(futureTask)`，利用thread对象.start()启动，或者创建线程池`ExecutorService executor = Executors.newCachedThreadPool()`,
利用excutor.submit(futureTask)启动针对Callable 有返回值， excutor.execute(futureTask)针对Runnable，无返回值。
4.利用futureTask.get()获取真正的结果。


# Collection的sort方法使用的排序算法
Collection.sort在内部也是转换为了Arrays.sort
```java
default void sort(Comparator<? super E> c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
```
Arrays.sort具体采用的排序算法如下：
基本类型  DualPivotQuicksort 双轴快速排序 

对象数组  LegacyMergeSort   归并排序   在后续的版本中会被删除   
         当count<7  使用Insertion sort(先获得一定长度的序列，然后再合并，在效率上将有所提高。)
         当count>=7 mergeSort
         
  
         ComparableTimSort(调用时无Comparator)/TimSort(调用时传递了Comparator) 
         当count<32 使用二分插入排序(binary sort)
         当count>=32 调用TimSort(调用时传递了Comparator)  

通过判断 排序的对象的数目，在排序算法的内部，进行优化，提高了效率。
但是为什么对于基本类型和对象数组，我们还是考虑了不同的排序算法呢？

这是考虑了排序算法的稳定性！！！！ 对于基础类型，相同值是没有差别的，排序的先后相同值的相对位置是并不重要的，所以采取了更为高效的快速排序，尽管它是不稳定的排序算法；对于非基础类型，排序前后相等的实例的相对位置不宜改变，所以采取稳定的归并排序或者ComparableTimSort

# default 关键字
接口中 定义default方法， 该方法可以写内部实现，且实现类可以选择不实现该方法。