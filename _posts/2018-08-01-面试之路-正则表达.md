---
layout:     post
title:      正则表达式
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---
正则表达式定义了字符串的模式。可以用来搜索、编辑或提取文本。
正则表达式引擎--NFA(不确定型有穷自动机)则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，
# 1.捕获组和非捕获组
```java
String text="<div style=\"color:#0000FF\">等待匹配的字符串</div>"
String reg="(<div.*?>)(?<data>.*?)(?:</div>)"; 
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
System.out.println(matcher.group("data"));

```
正则表达式中每个"()"内的部分作为一个捕获组，编号为0表示整个匹配内容。
当让你也可以通过变量来获取捕获组"(?<变量>)"

至于非捕获组将"()"变为"(?:)" 即可


# 2.贪婪，勉强，独占模式
对于文本"abbbc",正则表达式"ab{1,3}c"时 是不会发生回溯的。
但是对于文本"abc", 在匹配完b后，他会尽可能贪婪的用文本中的"c"去继续匹配正则表达式中的"b{1，3}"，直到完全不匹配后将字符"c"吐出，用正则表达式中的"c"进行匹配，从而发生了回溯。


这里就是正则的贪婪特性，他会竭尽所能的去匹配最多的字符，直到撞了南墙。
你可以在正则之后添加？ 开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串。
你也可以在正则之后添加+ 开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。


简单地说, 贪婪模式和占有模式相比, 贪婪模式会在只有部分匹配成功的条件下, 依次从多到少减少匹配成功部分模式的匹配数量, 将字符留给模式其他部分去匹配; 而占用模式则是占有所有能匹配成功部分, 绝不留给其他部分使用。

| 贪婪   | 懒惰    | 独占    |
|--------|---------|---------|
| X?     | X??     | X?+     |
| X*     | X*?     | X*+     |
| X+     | X+?     | X++     |
| X{n}   | X{n}?   | X{n}+   |
| X{n,}  | X{n,}?  | X{n,}+  |
| X{n,m} | X{n,m}? | X{n,m}+ |

贪婪型
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>aava </tr>
}
```

勉强型
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+?>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>
  // </tr>
```

独占型
它和最大匹配一样，一直匹配所有的字符，直到文本的最后，但它不由原路返回。因此会一直匹配.+，不回溯，由此没法完成正则表达式的匹配，因此不打印任何东西
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.++>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // 不进行打印
}
```


String类的三个正则操作：
matches();
split();
replaceAll();

java.utils.regex包中包含以下三个类：
- Pattern 类：模式类，用于表达和陈述所要搜索模式的对象。
- Matcher 类：匹配器类 搜索的对象。
- PatternSyntaxException 类： 不合法的搜索模式时，抛出的异常。