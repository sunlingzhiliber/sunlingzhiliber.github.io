---
layout:     post
title:      java-基础编程
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---
# 包装类
- new Integer(123) 每次会创建新的对象
- Integer.valueOf(123) 会使用缓存池中(缓存池Integer大小默认为-128~127)的对象，多次调用会取得同一个对象的引用
```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true

//注意128超出了缓存池
Integer h = Integer.valueOf(128);
Integer v = Integer.valueOf(128);
System.out.println(h == v);   // false
```


## 基本类型的缓存池
boolean values true and false
all byte values
short values between -128 and 127
int values between -128 and 127
char in the range \u0000 to \u007F

# hashcode()和equals()
1. `equals()` 
用于判断两个对象的地址是否相等（即  是否是同一个对象 if(this==obj) ），调用默认的`equals()`方法相当于使用`==`方法，判断内存地址，因此我们经常需要重写父类的equals()函数：如若两个对象的内容相等，`equals()`方法则返回true，反之返回false。
诸如`String,Interger,Date`等类的`equals`函数就被进行了覆盖。

我们注意在重写equals时，必须满足以下的要求：（其实我们在重写equals时，应当同时覆盖hashCode，以保证元素的唯一性）
```
1. 对称性：如果x.equals(y)返回是"true"，那么y.equals(x)也应该返回是"true"。
2. 反射性：x.equals(x)必须返回是"true"。
3. 类推性：如果x.equals(y)返回是"true"，而且y.equals(z)返回是"true"，那么z.equals(x)也应该返回是"true"。
4. 一致性：如果x.equals(y)返回是"true"，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是"true"。
5. 非空性，x.equals(null)，永远返回是"false"；x.equals(和x不同类型的对象)永远返回是"false"。
```

2. `hashCode()`
用于获取对象在哈希表中的索引位置， 虽然，每个Java类都包含hashCode()函数。但是，仅仅当创建并某个“HashTable”（HashMap，Hashtable，HashSet）时，该类的hashCode()才有用。
也就是说：**hashCode() 在散列表中才有用，在其它情况（线性表）下没用**。
在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。前提是散列表中
  - 如果两个对象相等，那么它们的hashCode()值一定要相同；
  - 如果两个对象hashCode()相等，它们并不一定equals()相等。

3. 两者的关系
当不创建”类的散列表“的时候，hashCode()和equals()没有任何联系。
当创建”类的散列表“的时候，他们是由关系的：
  - 1)如果两个对象equals()相等，那么它们的hashCode()值一定要相同；
  - 2)如果两个对象hashCode()相等，它们并不一定equals()相等。
    因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。
  - 3)如果两个对象hashCode()不相等，它们一定equals()不相等。
    因此在往散列集合中添加元素时，可以先比较hashCode(),相等后再比较equals(),提高比较的效率



# 泛型、异常、反射
 1. 异常和错误
 >异常实现程序的健壮性
 Java标准库中建了一些通用的异常，这些类都以Throwable为顶层父类。
 Throwable又派生出Error类和Exception类。根据类的派生关系，我们可以对Throwable进行分类：
 Error:代表了JVM本身的错误，这些错误不能被程序员通过代码进行处理，Error很少出现且难以处理。
 Exception：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。
 ![](/assets/images/something/error.png)

 另外我们可以根据JavaC对于异常的处理要求，将Throwable分为另类：
 非检查异常：Error以及RuntimeException，这些异常，在javac编译时，并不会提示与发现这些异常。当然我们也不建议通过异常不获取去处理这些错误。因为这些错误往往是代码本身就存在问题，我们应该修改代码以避免错误。
 检查异常：JavaC强制要求为此类异常做异常捕获与处理，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。

那么我们如何对异常进行处理呢？有两种方法
一种方法是利用try..catch..finally进行处理，另一种是throws异常声明 交给函数调用者caller去解决
```java
public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{ 
     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。
}

public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{ 
     try {

     }catch(ExceptionType1 ex1){
         //dosomething
     }catch(ExceptionType2 ex2){
         //dosomething
     }finally{
         //清理工作
     }
}

```


 2. 泛型
 >本质是，将类型由原来的具体 变成 类型参数化 ，提高代码的重用性，
 泛型的形式包括
 <T> <E> <K> <V> <T extends Number> <T super Number>  用于声明 类（类名之后），方法（方法返回值之前），
 <?> <? extends Number>(Number的子类都可以)  <? super Number> 通配符用于参数
 在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。


 泛型只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。
 
 **对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**
 同时是没有 ~~泛型数组~~ 这一定义,但是用通配符是可以的
```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.
List<String>[] lsa = new List<String>[10]; //error
```

 3. 反射
 >反射是框架设计的灵魂
Java的反射机制是在运行状态中，你都可以获取任意一个类，任意一个对象，并对它进行操作。

```java
Class stuClass3 = Class.forName("fanshe.Student");
```




# foreach循环的原理及注意点
只要想使用foreach循环遍历集合时，必须正确地实现Iterable接口，以此进行集合的遍历
```java
int a[]={1,2,3,4,5,6,7,8};
for (var i : a) {
    System.out.println(i);
}

List<String> b=new ArrayList<>();//List实现了Iterable接口
b.add("1");
b.add("2");
for (var s : b) {
    System.out.println(s);
}
```

注意我们在foreach 集合时，是不能 **删除/添加/修改** 集合内容，“只读”操作
>forEach() 与foreach是不用，forEach()是通过函数式接口 Consumer<T>实现的 可以使用lambda表达式



# static final 等关键字的作用
`static` 静态的，可以用来修饰 方法，类以及变量。同时也可以利用static代码块来优化程序性能。
1) 静态方法 ，静态方法不依赖对象就可以直接使用，当然因为不依赖对象，在其内部就无法使用类的非静态变量和非静态方法。
2) 静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，会在类的初次加载时初始化。
3) 静态代码块，通过控制代码运行顺序，以优化程序性能。
顺序：静态变量->静态代码块->实列变量->构造代码块->构造方法(注意继承时，父类优先)
```java
class Work {
    private static int start;
    private static int end;
    private String name;
    static {//静态代码块，只会执行一次，常用于类 属性的初始化(只用于静态变量)
        start=1;
        end=2;
    }
    {//构造代码块，每次 声明对象时调用， 优先于构造函数执行 
        name="Type";
    }

    public Work(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```
------------------

`final` 无法改变的，你将无法改变这个引用，它可以用于修饰变量、方法和类。经过final修饰，JVM会对其进行优化。
1) final变量 final总是和static一起使用，用来声明一个 **只读常量** 。必须在声明的时候初始化或者在构造函数中初始化。final变量应该大写。
对于集合对象为final类型时，我们可以向其添加，删除以及修改其内容， 但是不能改变它的引用
```java
public class Main {
    private static final List list = new ArrayList();
    public static void main(String[] args) throws IOException {
        list.add("String");
        list.forEach(System.out::println);
        list=null; //not valid
    }
}
```

2) final方法 fianl方法标志着不可被子类的发方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。
3) final类   final类的功能是完整的，它不能被继承。java中具有很多final类，比如String、Interger等。


# 序列化、反序列化和transient
序列化：将一个对象转成一串二进制表示的字节数组，通过保存或者转移这些字节数据来达到持久化的目的。
反序列化：将字节数组重新构建为对象。

那我们做序列化和反序列化是为了什么呢？ 为了 **持久化**。持久化，就是我们将内存中的对象给 ~~持久~~ 的存储起来。这里我们就有个疑问？我们不用使用序列化 也可以将对象存储到文件中，那么为什么需要序列化呢?

- 存储到数据库\文件中
- 网络传输
- RMI(remote method invocation,它是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上)传输对象
- 读取JavaBean状态


当一个类实现了接口Serilizable，这个对象就可以实现序列化和反序列化。
同时这个类我们并不想它的所有字段都进行序列化，由此我们可以用transient来修饰变量。

注意transient要和接口java.io.Serializable一起使用，





# volatile
volatile关键字的作用是保证变量在多线程之间的可见性，他也可以保证有序性。它是java并发开发的核心基础。
1. valatile的两层语义
   一旦一个共享变量被volatile修饰后，
   1) 不同线程对这个变量进行操作后，都会立即可见。（修改后，会立即写入主存，会使其他线程的缓存无效）
   2) 禁止进行指令重排序。（重排序时，在volatile变量之前的操作已经完成，在volatile之后的没有进行）

2. 实现
有valatile修饰的变量，在其汇编代码之前可以看到 lock，该lock（内存屏障）会触发两件事
  - 将当前处理器缓存行的数据立即写回到系统内存。(一般是写到缓存后，是不确定什么时候会写到内存)
  - 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。
  - 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

3. 使用条件
  对变量的写操作不依赖于当前值
  该变量没有包含在具有其他变量的不变式中

4. 应用场景
  状态标记量，Double Check






# String
String 是被声明为final类，不可被继承。保证String不可变
## 不可变的好处
1. 可以缓存hash值
因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2.  String Pool 的需要
如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool
3. 安全性
String 经常作为参数，String 不可变性可以保证参数不可变。
4. 线程安全
String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

## string的 intern方法的内部细节
检测字符串常量池是否存在对应字符串，
若存在，则返回池中的字符串，若不存在，该方法会添加原字符串在存储堆中的引用到字符串池，再返回该引用。
```java
String a=new String("test");//指向堆  创建了两个对象，常量池中的”test”和堆中对象。
String s=a.intern();//指向常量池
System.out.println(s==a);//false


String str2 = new String("str")+new String("01");//str 01 都会进入常量池，字符串的+ 是通过StringBuilder append 后 再 ToString（）的 ，str01只会在堆中
str2.intern();//此时常量池不存在str01 因此intern之后，添加原字符串在存储堆中的引用到字符串池，再返回该引用。
String str1 = "str01";//str01在常量池中的引用 是指向堆中的字符串“str01”
System.out.println(str2==str1);//true
```

## String的equals()和hashCode()
>这里我们特别注意字符串的equals()的调用，String::equals 是覆盖了Object的equals函数

只要字符串内容相同，字符串则equals()相等

>这里我们特别注意字符串的hashcode的调用，String::hashCode 是覆盖了Object的hashCode函数
```java
    public static int hashCode(byte[] value) {
        int h = 0;
        for (byte v : value) {
            h = 31 * h + (v & 0xff);
        }
        return h;
    }
```
从代码可以看出，只要他们value一致，他们的hashCode()就是一致的。但是他们的hashCode()一致，不能说明他们value一致，比如字符串"Aa"和"BB"。(在理想情况下：**为不同的对象产生不相等的hashCode**，但是这种理想情形是非常困难的，因为hachCode的生成是非随机生成的，它有一定的规律，同时这个规律就是每个hash算法的优势所在。))

特点： 相同前缀的字符串所生成的hash值是相邻的


## 字符串常量池
字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。
![常量池情形](/assets/images/something/string.png)

JVM为了减少字符串对象的重复创建，维护了一段特别的内存称为字符串常量池，每次通过字面量形式创建字符串时，会首先取字符串常量池中读取是否已存在，已存在则将引用返回。

我们要首先认识到String 是不可变的，是final修饰的。因此多个变量可以共享同一个对象，由此才有字符串常量池的说法。同时因为是final不可变类型，也出现了有效防止字符串被修改的情况


当然String对象的不可变设计，可以在Hash类型进行缓存hashCode时，执行效率提升。

```java
final String h="sunlingzhi";
String s="sunlingzhi";//指向常量池
String y="sunlingzhi";
System.out.println(s==y);//true 
String z=new String("sunlingzhi");//指向堆空间
System.out.println(s==z);//false  s和z不是同一个对象


String v=s+y; //stringBuilder.append() 非final字段在运行期进行赋值处理 指向堆

String a=h+"sunlingzhi"//常量池  final字段编译期会进行常量替换 指向常量池


//额外注意hashCode和equals函数
//s、y、z  他们三者两两的以上函数 都为true
```







# hash冲突：拉链法
我们先来看看HashMap  put时的情形
```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key) {
    int h;
    //获取key的hashCode(),
    //获取hashCode()16个高位 进行异或操作
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

put方法的实现是根据key的hashCode进行hash运算，得到值hash；
根据hash值去确定数组的位置，index=hash& (table.length.-1)（效率高）
length是2的次方
说明：
```
  x % 2的n次方= x & (2的n次方-1);
  HashMap的数组长度，总是2的n次方
  因此 位桶的位置 index= hash & (length -1) //等价于 hash % length，采用位运算效率高
```

>Java中每个位桶都是采用的链表+红黑树来实现的。
![HashMap](/assets/images/something/hashMap.png)
在我们明白HashMap是如何进行put之后，我们来讨论什么是哈希冲突？
其实就是再采用哈希函数对输入域进行映射到哈希表的时候，因为哈希表的位桶的数目远小于输入域的关键字的个数，所以，对于输入域的关键字来说，很可能会产生这样一种情况，也就是，不同关键字会映射到同一个位桶中的情况。
Java中是使用拉链式来解决冲突的，
```java
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        // table是否为空或者length等于0, 如果是则调用resize方法进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else { // table表该索引位置不为空
            Node<K,V> e; K k;
            if (p.hash == hash &&// 判断p节点的hash值和key值是否跟传入的hash值和key值相等
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;// 如果相等, 则p节点即为要查找的目标节点，赋值给e
            else if (p instanceof TreeNode) //添加红黑树
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {// 走到这代表p节点为普通链表节点
                for (int binCount = 0; ; ++binCount) {// 遍历此链表, binCount用于统计节点数
                    if ((e = p.next) == null) {// p.next为空代表不存在目标节点则新增一个节点插入链表尾部
                        p.next = newNode(hash, key, value, null);

                         // 计算节点是否超过 TREEIFY_THRESHOLD（8）个, 减一是因为循环是从p节点的下一个节点开始的
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);// 如果超过8个，调用treeifyBin方法将该链表转换为红黑树
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e; // 将p指向下一个节点
                }
            }
            // e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);// 用于LinkedHashMap
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)  // 插入节点后超过阈值则进行扩容
            resize();
        afterNodeInsertion(evict);  // 用于LinkedHashMap
        return null;
    }
```

# 如何创建线程
java 1.5之前，创建启动一个线程可以 继承Thread类，也可以 实现Runnable接口，但是这两种凡是都无法获取执行任务之后的执行结果。
Thread类只支持Runnable
```java
public interface Runnable {//返回值为void，所以无法返回结果
    public abstract void run();
}
```
1.5之后，java提供了Callable和Future接口，实现Callable接口，使用Future结果就可以获取线程运行结果。


# Callable Future 和 FutureTask

`Callable` 接口和 `Runnable` 接口很相似，但是其call方法有返回值，所以可以获取线程执行的返回值。
Thread类不支持Callable，因此需要使用ExecuteService来执行。
```java
public interface Callable<V> {
    V call() throws Exception;
}
```

`Future`就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。
`Future` 接口 声明了5个方法，分别是：
1) cancel()      用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。
2) isCancelled() 表示任务是否被取消成功。
3) isDone()      表示任务是否完成。
4) get()         获取任务的执行结果，这个方法会产生 **阻塞** ，一直等到任务执行完毕才返回。
5) get(long timeout,TimeUnit unit)   获取任务执行结果，如果在timeout时间内没有获取到结果，就直接返回null。
>Future可以判断任务是否完成，能够中断任务，能够获取任务执行结果。但是future只是接口，是无法直接用来创建对象使用的，因此有了FutureTask。


`FutureTask`  实现了RunnableFuture<V>接口->RunnableFuture<V>接口实现了Future和Runnable接口
1)FutureTask是Future接口的一个唯一实现类。 
2)FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可以提交给ExecuteService(->Callable)来执行。
```java
public interface ExecutorService extends Executor {
    <T> Future<T> submit(Callable<T> task);//常用
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);//常用

    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);
}
``` 
3)FutureTask实现了Futrue可以直接通过get()函数获取执行结果，该函数会阻塞，直到结果返回。

另外它还可以包装Runnable和Callable，由构造函数注入
```java
 public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```
我们能看出，Runnable最后也会被转换为Callable执行，即FutureTask最终都是执行Callable类型的任务。

这里我们将介绍使用流程：
1.创建Runnable实现类对象或者Callable实现类对象。
2.创建FutureTash对象，将Runnable实现类对象或者Callable实现类对象作为参数、
3.创建Thread `Thread thread=new Thread(futureTask)`，利用thread对象.start()启动，或者创建线程池`ExecutorService executor = Executors.newCachedThreadPool()`,
利用excutor.submit(futureTask)启动针对Callable 有返回值， excutor.execute(futureTask)针对Runnable，无返回值。
4.利用futureTask.get()获取真正的结果。


# Collection的sort方法使用的排序算法
Collection.sort在内部也是转换为了Arrays.sort
```java
default void sort(Comparator<? super E> c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
```
Arrays.sort具体采用的排序算法如下：
基本类型  DualPivotQuicksort 双轴快速排序 

对象数组  LegacyMergeSort   归并排序   在后续的版本中会被删除   
         当count<7  使用Insertion sort(先获得一定长度的序列，然后再合并，在效率上将有所提高。)
         当count>=7 mergeSort
         
  
         ComparableTimSort(调用时无Comparator)/TimSort(调用时传递了Comparator) 
         当count<32 使用二分插入排序(binary sort)
         当count>=32 调用TimSort(调用时传递了Comparator)  

通过判断 排序的对象的数目，在排序算法的内部，进行优化，提高了效率。
但是为什么对于基本类型和对象数组，我们还是考虑了不同的排序算法呢？

这是考虑了排序算法的稳定性！！！！ 对于基础类型，相同值是没有差别的，排序的先后相同值的相对位置是并不重要的，所以采取了更为高效的快速排序，尽管它是不稳定的排序算法；对于非基础类型，排序前后相等的实例的相对位置不宜改变，所以采取稳定的归并排序或者ComparableTimSort

# default 关键字
接口中 定义default方法， 该方法可以写内部实现，且实现类可以选择不实现该方法。


正则表达式定义了字符串的模式。可以用来搜索、编辑或提取文本。
正则表达式引擎--NFA(不确定型有穷自动机)则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，
# 1.捕获组和非捕获组
```java
String text="<div style=\"color:#0000FF\">等待匹配的字符串</div>"
String reg="(<div.*?>)(?<data>.*?)(?:</div>)"; 
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
System.out.println(matcher.group("data"));

```
正则表达式中每个"()"内的部分作为一个捕获组，编号为0表示整个匹配内容。
当让你也可以通过变量来获取捕获组"(?<变量>)"

至于非捕获组将"()"变为"(?:)" 即可


# 2.贪婪，勉强，独占模式
对于文本"abbbc",正则表达式"ab{1,3}c"时 是不会发生回溯的。
但是对于文本"abc", 在匹配完b后，他会尽可能贪婪的用文本中的"c"去继续匹配正则表达式中的"b{1，3}"，直到完全不匹配后将字符"c"吐出，用正则表达式中的"c"进行匹配，从而发生了回溯。


这里就是正则的贪婪特性，他会竭尽所能的去匹配最多的字符，直到撞了南墙。
你可以在正则之后添加？ 开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串。
你也可以在正则之后添加+ 开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。


简单地说, 贪婪模式和占有模式相比, 贪婪模式会在只有部分匹配成功的条件下, 依次从多到少减少匹配成功部分模式的匹配数量, 将字符留给模式其他部分去匹配; 而占用模式则是占有所有能匹配成功部分, 绝不留给其他部分使用。

| 贪婪   | 懒惰    | 独占    |
|--------|---------|---------|
| X?     | X??     | X?+     |
| X*     | X*?     | X*+     |
| X+     | X+?     | X++     |
| X{n}   | X{n}?   | X{n}+   |
| X{n,}  | X{n,}?  | X{n,}+  |
| X{n,m} | X{n,m}? | X{n,m}+ |

贪婪型
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>aava </tr>
}
```

勉强型
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+?>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>
  // </tr>
```

独占型
它和最大匹配一样，一直匹配所有的字符，直到文本的最后，但它不由原路返回。因此会一直匹配.+，不回溯，由此没法完成正则表达式的匹配，因此不打印任何东西
```java
String text = "a<tr>aava </tr>abb ";
String reg="<.++>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // 不进行打印
}
```


String类的三个正则操作：
matches();
split();
replaceAll();

java.utils.regex包中包含以下三个类：
- Pattern 类：模式类，用于表达和陈述所要搜索模式的对象。
- Matcher 类：匹配器类 搜索的对象。
- PatternSyntaxException 类： 不合法的搜索模式时，抛出的异常。


# 序列化和反序列化
序列化就是将二进制数据转化为对象。
反序列化就是将对象转化为二进制数据。

# 注解
在项目开发中，注解的使用无处不在。注解的使用简化了代码，减少了程序员的工作量。本课程带领小伙伴们全面认识Java的注解，包括为什么使用注解、Java中的常见注解、注解的分类和如何自定义注解，最后通过一个实战案例来演示注解在实际项目中的应用。



# BIO、NIO与AIO


- BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。

- NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。

- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。





Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。
Java NIO: Channels and Buffers（通道和缓冲区）
标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
Java NIO: Non-blocking IO（非阻塞IO）
Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。
Java NIO: Selectors（选择器）
Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。


# java容器

## HashMap
HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
Hashmap 不是同步的，如果多个线程同时访问一个 HashMap，而其中至少一个线程从结构上（指添加或者删除一个或多个映射关系的任何操作）修改了，则必须保持外部同步，以防止对映射进行意外的非同步访问。
HahMap就是数组和链表的结合体。
注意`遍历使用entry`
![](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181011205122.png)

```java
HashMap<String, String> map = new HashMap<>();
map.put("K1", "V1");
map.put("K2", "V2");
map.put("K3", "V3");
```
- 新建一个 HashMap，默认大小为 16；
- 插入 <K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。
- 插入 <K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留- 余数法得到所在的桶下标 118%16=6。
- 插入 <K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 <K2,V2> 前面。

应该注意到链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头部。

查找需要分成两步进行：
- 计算键值对所在的桶；
- 在链表上顺序查找，时间复杂度显然和链表的长度成正比。
![](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181011205320.png)


注意当链表长度大于8时，需要将链表转为红黑树


### 并发访问HashMap的问题
[循环链表，执行get操作，死循环](https://www.jianshu.com/p/1e9cf0ac07f4)


## TreeMap
排好序的Map


## Hashtable
- HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。
- Hashtable 方法是同步（加锁），而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，
- HashTable的key、value都不可以为null。此外，Hashtable中的映射不是有序的。

## ConcurrentHashMap 
线程安全

ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。



注意当链表长度大于8时，需要将链表转为红黑树

## HashSet
HashSet的底层使用了HashMap来陈宝存元素。

由于 HashMap 的 put() 方法添加 key-value 对时，当新放入 HashMap 的 Entry 中 key 与集合中原有 Entry 的 key 相同（hashCode()返回值相等，通过 equals 比较也返回 true），新添加的 Entry 的 value 会将覆盖原来 Entry 的 value（HashSet 中的 value 都是PRESENT），但 key 不会有任何改变，因此如果向 HashSet 中添加一个已经存在的元素时，新添加的集合元素将不会被放入 HashMap中，原来的元素也不会有任何改变，这也就满足了 Set 中元素不重复的特性。

## TreeSet
是二叉树实现的，是排序顺序的，不允许放入null值。当需要排序的功能时，我们才使用TreeSet，而不考虑HashSet






## LinkedHashMap
具有顺序的HashMap，这里顺序可是设置为插入顺序，也可以设置为访问顺序。

### LCU
LRU 缓存利用了这样的一种思想。LRU 是 Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU 缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用 LRU 缓存，我们能够提高系统的 performance。

要实现 LRU 缓存，我们首先要用到一个类 LinkedHashMap。

用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap 本身有一个方法用于判断是否需要移除最不常读取的数，但是，原始方法默认不需要移除（这是，LinkedHashMap 相当于一个linkedlist），所以，我们需要 override 这样一个方法，使得当缓存里存放的数据个数超过规定个数后，就把最不常用的移除掉。


## LinkedHashSet
具有顺序的HashSet，这里顺序可是设置为插入顺序，也可以设置为访问顺序。

## ArrayList
可变长动态数组，为了线程安全可以考虑 
```java
Collections.synchronizedList(); //得到一个线程安全的 ArrayList。
```

## CopyOnWriteArrayList
写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。
写操作需要加锁，防止并发写入时导致写入数据丢失。
写操作结束之后需要把原始数组指向新的复制数组。

CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

但是 CopyOnWriteArrayList 有其缺陷：

内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。
所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景

## LinkedList 
双向链表实现的List，它的插入和删除更加有效。

## Vecotr
可变长数组 线程安全，同步的。

## PriorityQueue
优先队列（本质是堆实现的），队列中的元素是有优先级的，优先级最高的元素就排在队列的第一位，当我们从队列中去取的是，得到的是优先级最高的那个元素。这个优先级我们是可以自己定义的，比如值最大的，优先级最高，也可以定义成值最小的，优先级最高，甚至可以指定比较某个具体的对象的某个属性，比如学生的学号，年龄这种的。


# 接口default方法的重要性
添加新方法而不需要原本已经存在的实现该接口的类做任何改变（甚至不需要重新编译）就可以使用该新版本的接口。