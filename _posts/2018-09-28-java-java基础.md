---
layout:     post
title:      java-基础编程
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# 包装类

- new Integer(123) 每次会创建新的对象
- Integer.valueOf(123) 会使用缓存池中(缓存池Integer大小默认为-128~127)的对象，多次调用会取得同一个对象的引用

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true

//注意128超出了缓存池
Integer h = Integer.valueOf(128);
Integer v = Integer.valueOf(128);
System.out.println(h == v);   // false
```

## 基本类型的缓存池

boolean values true and false
all byte values
short values between -128 and 127
int values between -128 and 127
char in the range \u0000 to \u007F

# hashcode()和equals()

1. `equals()`

用于判断两个对象的地址是否相等（即  是否是同一个对象 if(this==obj) ），调用默认的`equals()`方法相当于使用`==`方法，判断内存地址，因此我们经常需要重写父类的equals()函数：如若两个对象的内容相等，`equals()`方法则返回true，反之返回false。
诸如`String,Interger,Date`等类的`equals`函数就被进行了覆盖。

我们注意在重写equals时，必须满足以下的要求：（其实我们在重写equals时，应当同时覆盖hashCode，以保证元素的唯一性）

```text
1. 对称性：如果x.equals(y)返回是"true"，那么y.equals(x)也应该返回是"true"。
2. 反射性：x.equals(x)必须返回是"true"。
3. 类推性：如果x.equals(y)返回是"true"，而且y.equals(z)返回是"true"，那么z.equals(x)也应该返回是"true"。
4. 一致性：如果x.equals(y)返回是"true"，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是"true"。
5. 非空性，x.equals(null)，永远返回是"false"；x.equals(和x不同类型的对象)永远返回是"false"。
```

2.`hashCode()`

用于获取对象在哈希表中的索引位置， 虽然，每个Java类都包含hashCode()函数。但是，仅仅当创建并某个“HashTable”（HashMap，Hashtable，HashSet）时，该类的hashCode()才有用。
也就是说：**hashCode() 在散列表中才有用，在其它情况（线性表）下没用**。
在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。前提是散列表中

- 如果两个对象相等，那么它们的hashCode()值一定要相同；
- 如果两个对象hashCode()相等，它们并不一定equals()相等。

3.两者的关系

当不创建”类的散列表“的时候，hashCode()和equals()没有任何联系。
当创建”类的散列表“的时候，他们是由关系的：

- 1)如果两个对象equals()相等，那么它们的hashCode()值一定要相同；
- 2)如果两个对象hashCode()相等，它们并不一定equals()相等。
    因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。
- 3)如果两个对象hashCode()不相等，它们一定equals()不相等。
    因此在往散列集合中添加元素时，可以先比较hashCode(),相等后再比较equals(),提高比较的效率

# 异常

 >异常实现程序的健壮性

 Java标准库中建了一些通用的异常，这些类都以Throwable为顶层父类。
 Throwable又派生出Error类和Exception类。根据类的派生关系，我们可以对Throwable进行分类：
 Error:代表了JVM本身的错误，这些错误不能被程序员通过代码进行处理，Error很少出现且难以处理。
 Exception：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

 ![error](/assets/images/something/error.png)

 另外我们可以根据JavaC对于异常的处理要求，将Throwable分为另类：
 非检查异常：Error以及RuntimeException，这些异常，在javac编译时，并不会提示与发现这些异常。当然我们也不建议通过异常不获取去处理这些错误。因为这些错误往往是代码本身就存在问题，我们应该修改代码以避免错误。
 检查异常：JavaC强制要求为此类异常做异常捕获与处理，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。

那么我们如何对异常进行处理呢？有两种方法
一种方法是利用try..catch..finally进行处理，另一种是throws异常声明 交给函数调用者caller去解决

```java
public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{
     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。
}

public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{
     try {

     }catch(ExceptionType1 ex1){
         //dosomething
     }catch(ExceptionType2 ex2){
         //dosomething
     }finally{
         //清理工作
     }
}

```

# 泛型

>本质是，将类型由原来的具体 变成 类型参数化 ，提高代码的重用性，

泛型的形式包括
`<T> <E> <K> <V> <T extends Number> <T super Number>`  用于声明 类（类名之后），方法（方法返回值之前），
`<?> <? extends Number>`(Number的子类都可以)  `<? super Number>` 通配符用于参数
在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。

泛型只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。

**对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**
 同时是没有 ~~泛型数组~~ 这一定义,但是用通配符是可以的

```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.
List<String>[] lsa = new List<String>[10]; //error
```

# 反射

 >反射是框架设计的灵魂
Java的反射机制是在运行状态中，你都可以获取任意一个类，任意一个对象，并对它进行操作。

```java
Class stuClass3 = Class.forName("fanshe.Student");
```

# foreach循环的原理及注意点

只要想使用foreach循环遍历集合时，必须正确地实现Iterable接口，以此进行集合的遍历

```java
int a[]={1,2,3,4,5,6,7,8};
for (var i : a) {
    System.out.println(i);
}

List<String> b=new ArrayList<>();//List实现了Iterable接口
b.add("1");
b.add("2");
for (var s : b) {
    System.out.println(s);
}
```

注意我们在foreach 集合时，是不能 **删除/添加/修改** 集合内容，“只读”操作
>forEach() 与foreach是不用，forEach()是通过函数式接口 Consumer<T>实现的 可以使用lambda表达式

# static final 等关键字的作用

`static` 静态的，可以用来修饰 方法，类以及变量。同时也可以利用static代码块来优化程序性能。
1) 静态方法 ，静态方法不依赖对象就可以直接使用，当然因为不依赖对象，在其内部就无法使用类的非静态变量和非静态方法。
2) 静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，会在类的初次加载时初始化。
3) 静态代码块，通过控制代码运行顺序，以优化程序性能。
顺序：静态变量->静态代码块->实列变量->构造代码块->构造方法(注意继承时，父类优先)

```java
class Work {
    private static int start;
    private static int end;
    private String name;
    static {//静态代码块，只会执行一次，常用于类 属性的初始化(只用于静态变量)
        start=1;
        end=2;
    }
    {//构造代码块，每次 声明对象时调用， 优先于构造函数执行
        name="Type";
    }

    public Work(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```

------------------

`final` 无法改变的，你将无法改变这个引用，它可以用于修饰变量、方法和类。经过final修饰，JVM会对其进行优化。
1)final变量 final总是和static一起使用，用来声明一个 **只读常量** 。必须在声明的时候初始化或者在构造函数中初始化，否则会编译错误，并且不允许对其修改。
final变量应该大写。

对于集合对象为final类型时，我们可以向其添加，删除以及修改其内容， 但是不能改变它的引用

```java
public class Main {
    private static final List list = new ArrayList();
    public static void main(String[] args) throws IOException {
        list.add("String");
        list.forEach(System.out::println);
        list=null; //not valid
    }
}
```

2)final方法 fianl方法标志着不可被子类的发方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。
3)final类   final类的功能是完整的，它不能被继承。java中具有很多final类，比如String、Interger等。

# 序列化、反序列化和transient

序列化：将一个对象转成一串二进制表示的字节数组，通过保存或者转移这些字节数据来达到持久化的目的。
反序列化：将字节数组重新构建为对象。

那我们做序列化和反序列化是为了什么呢？ 为了 **持久化**。持久化，就是我们将内存中的对象给 ~~持久~~ 的存储起来。这里我们就有个疑问？我们不用使用序列化 也可以将对象存储到文件中，那么为什么需要序列化呢?

- 存储到数据库\文件中
- 网络传输
- RMI(remote method invocation,它是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上)传输对象
- 读取JavaBean状态

当一个类实现了接口Serilizable，这个对象就可以实现序列化和反序列化。

同时这个类我们并不想它的所有字段都进行序列化，由此我们可以用transient来修饰变量。[典型列子,ArrayList](#arraylist)

注意transient要和接口java.io.Serializable一起使用，

# String

String 是被声明为final类，不可被继承。保证String不可变

## 不可变的好处

1. 可以缓存hash值

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2.  String Pool 的需要

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool
3. 安全性

String 经常作为参数，String 不可变性可以保证参数不可变。
4. 线程安全

String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

## string的 intern方法的内部细节

检测字符串常量池是否存在对应字符串，
若存在，则返回池中的字符串，若不存在，该方法会添加原字符串在存储堆中的引用到字符串池，再返回该引用。

```java
String a=new String("test");//指向堆  创建了两个对象，常量池中的”test”和堆中对象。
String s=a.intern();//指向常量池
System.out.println(s==a);//false


String str2 = new String("str")+new String("01");//str 01 都会进入常量池，字符串的+ 是通过StringBuilder append 后 再 ToString（）的 ，str01只会在堆中
str2.intern();//此时常量池不存在str01 因此intern之后，添加原字符串在存储堆中的引用到字符串池，再返回该引用。
String str1 = "str01";//str01在常量池中的引用 是指向堆中的字符串“str01”
System.out.println(str2==str1);//true
```

## String的equals()和hashCode()

>这里我们特别注意字符串的equals()的调用，String::equals 是覆盖了Object的equals函数

只要字符串内容相同，字符串则equals()相等

>这里我们特别注意字符串的hashcode的调用，String::hashCode 是覆盖了Object的hashCode函数

```java
    public static int hashCode(byte[] value) {
        int h = 0;
        for (byte v : value) {
            h = 31 * h + (v & 0xff);
        }
        return h;
    }
```

从代码可以看出，只要他们value一致，他们的hashCode()就是一致的。但是他们的hashCode()一致，不能说明他们value一致，比如字符串"Aa"和"BB"。(在理想情况下：**为不同的对象产生不相等的hashCode**，但是这种理想情形是非常困难的，因为hachCode的生成是非随机生成的，它有一定的规律，同时这个规律就是每个hash算法的优势所在。))

特点： 相同前缀的字符串所生成的hash值是相邻的

## 字符串常量池

字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。
![常量池情形](/assets/images/something/string.png)

JVM为了减少字符串对象的重复创建，维护了一段特别的内存称为字符串常量池，每次通过字面量形式创建字符串时，会首先取字符串常量池中读取是否已存在，已存在则将引用返回。

我们要首先认识到String 是不可变的，是final修饰的。因此多个变量可以共享同一个对象，由此才有字符串常量池的说法。同时因为是final不可变类型，也出现了有效防止字符串被修改的情况

当然String对象的不可变设计，可以在Hash类型进行缓存hashCode时，执行效率提升。

```java
final String h="sunlingzhi";
String s="sunlingzhi";//指向常量池
String y="sunlingzhi";
System.out.println(s==y);//true 
String z=new String("sunlingzhi");//指向堆空间
System.out.println(s==z);//false  s和z不是同一个对象


String v=s+y; //stringBuilder.append() 非final字段在运行期进行赋值处理 指向堆

String a=h+"sunlingzhi"//常量池  final字段编译期会进行常量替换 指向常量池


//额外注意hashCode和equals函数
//s、y、z  他们三者两两的以上函数 都为true
```

# hash冲突：拉链法

我们先来看看HashMap  put时的情形

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key) {
    int h;
    //获取key的hashCode(),
    //获取hashCode()16个高位 进行异或操作
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

put方法的实现是根据key的hashCode进行hash运算，得到值hash；
根据hash值去确定数组的位置，index=hash& (table.length.-1)（效率高）
length是2的次方
说明：

```text
  x % 2的n次方= x & (2的n次方-1);
  HashMap的数组长度，总是2的n次方
  因此 位桶的位置 index= hash & (length -1) //等价于 hash % length，采用位运算效率高
```

>Java中每个位桶都是采用的链表+红黑树来实现的。
![HashMap](/assets/images/something/hashMap.png)
在我们明白HashMap是如何进行put之后，我们来讨论什么是哈希冲突？
其实就是再采用哈希函数对输入域进行映射到哈希表的时候，因为哈希表的位桶的数目远小于输入域的关键字的个数，所以，对于输入域的关键字来说，很可能会产生这样一种情况，也就是，不同关键字会映射到同一个位桶中的情况。
Java中是使用拉链式来解决冲突的，

```java
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        // table是否为空或者length等于0, 如果是则调用resize方法进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else { // table表该索引位置不为空
            Node<K,V> e; K k;
            if (p.hash == hash &&// 判断p节点的hash值和key值是否跟传入的hash值和key值相等
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;// 如果相等, 则p节点即为要查找的目标节点，赋值给e
            else if (p instanceof TreeNode) //添加红黑树
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {// 走到这代表p节点为普通链表节点
                for (int binCount = 0; ; ++binCount) {// 遍历此链表, binCount用于统计节点数
                    if ((e = p.next) == null) {// p.next为空代表不存在目标节点则新增一个节点插入链表尾部
                        p.next = newNode(hash, key, value, null);

                         // 计算节点是否超过 TREEIFY_THRESHOLD（8）个, 减一是因为循环是从p节点的下一个节点开始的
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);// 如果超过8个，调用treeifyBin方法将该链表转换为红黑树
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e; // 将p指向下一个节点
                }
            }
            // e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);// 用于LinkedHashMap
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)  // 插入节点后超过阈值则进行扩容
            resize();
        afterNodeInsertion(evict);  // 用于LinkedHashMap
        return null;
    }
```

# 如何创建线程

java 1.5之前，创建启动一个线程可以 继承Thread类，也可以 实现Runnable接口，但是这两种凡是都无法获取执行任务之后的执行结果。
Thread类只支持Runnable

```java
public interface Runnable {//返回值为void，所以无法返回结果
    public abstract void run();
}
```

1.5之后，java提供了Callable和Future接口，实现Callable接口，使用Future结果就可以获取线程运行结果。

# Callable Future 和 FutureTask

`Callable` 接口和 `Runnable` 接口很相似，但是其call方法有返回值，所以可以获取线程执行的返回值。
Thread类不支持Callable，因此需要使用ExecuteService来执行。

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

`Future`就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。
`Future` 接口 声明了5个方法，分别是：
1) cancel()      用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。
2) isCancelled() 表示任务是否被取消成功。
3) isDone()      表示任务是否完成。
4) get()         获取任务的执行结果，这个方法会产生 **阻塞** ，一直等到任务执行完毕才返回。
5) get(long timeout,TimeUnit unit)   获取任务执行结果，如果在timeout时间内没有获取到结果，就直接返回null。
>Future可以判断任务是否完成，能够中断任务，能够获取任务执行结果。但是future只是接口，是无法直接用来创建对象使用的，因此有了FutureTask。

`FutureTask`  实现了 RunnableFuture<V> 接口->RunnableFuture<V>接口实现了Future和Runnable接口
1)FutureTask是Future接口的一个唯一实现类。
2)FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可以提交给ExecuteService(->Callable)来执行。

```java
public interface ExecutorService extends Executor {
    <T> Future<T> submit(Callable<T> task);//常用
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);//常用

    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);
}
```

3)FutureTask实现了Futrue可以直接通过get()函数获取执行结果，该函数会阻塞，直到结果返回。

另外它还可以包装Runnable和Callable，由构造函数注入

```java
 public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```

我们能看出，Runnable最后也会被转换为Callable执行，即FutureTask最终都是执行Callable类型的任务。

这里我们将介绍使用流程：
1.创建Runnable实现类对象或者Callable实现类对象。
2.创建FutureTash对象，将Runnable实现类对象或者Callable实现类对象作为参数、
3.创建Thread `Thread thread=new Thread(futureTask)`，利用thread对象.start()启动，或者创建线程池`ExecutorService executor = Executors.newCachedThreadPool()`,
利用excutor.submit(futureTask)启动针对Callable 有返回值， excutor.execute(futureTask)针对Runnable，无返回值。
4.利用futureTask.get()获取真正的结果。

# Collection的sort方法使用的排序算法

Collection.sort在内部也是转换为了Arrays.sort

```java
default void sort(Comparator<? super E> c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
```

Arrays.sort具体采用的排序算法如下：
基本类型  DualPivotQuicksort 双轴快速排序 

对象数组  LegacyMergeSort   归并排序   在后续的版本中会被删除   
         当count<7  使用Insertion sort(先获得一定长度的序列，然后再合并，在效率上将有所提高。)
         当count>=7 mergeSort
         ComparableTimSort(调用时无Comparator)/TimSort(调用时传递了Comparator) 
         当count<32 使用二分插入排序(binary sort)
         当count>=32 调用TimSort(调用时传递了Comparator)  

通过判断 排序的对象的数目，在排序算法的内部，进行优化，提高了效率。
但是为什么对于基本类型和对象数组，我们还是考虑了不同的排序算法呢？

这是考虑了排序算法的稳定性！！！！ 对于基础类型，相同值是没有差别的，排序的先后相同值的相对位置是并不重要的，所以采取了更为高效的快速排序，尽管它是不稳定的排序算法；对于非基础类型，排序前后相等的实例的相对位置不宜改变，所以采取稳定的归并排序或者ComparableTimSort

# default 关键字

接口中 定义default方法， 该方法可以写内部实现，且实现类可以选择不实现该方法。

正则表达式定义了字符串的模式。可以用来搜索、编辑或提取文本。
正则表达式引擎--NFA(不确定型有穷自动机)则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，

# 1.捕获组和非捕获组

```java
String text="<div style=\"color:#0000FF\">等待匹配的字符串</div>"
String reg="(<div.*?>)(?<data>.*?)(?:</div>)";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
System.out.println(matcher.group("data"));
```

正则表达式中每个"()"内的部分作为一个捕获组，编号为0表示整个匹配内容。
当让你也可以通过变量来获取捕获组"(?<变量>)"

至于非捕获组将"()"变为"(?:)" 即可

# 2.贪婪，勉强，独占模式

对于文本"abbbc",正则表达式"ab{1,3}c"时 是不会发生回溯的。
但是对于文本"abc", 在匹配完b后，他会尽可能贪婪的用文本中的"c"去继续匹配正则表达式中的"b{1，3}"，直到完全不匹配后将字符"c"吐出，用正则表达式中的"c"进行匹配，从而发生了回溯。

这里就是正则的贪婪特性，他会竭尽所能的去匹配最多的字符，直到撞了南墙。
你可以在正则之后添加？ 开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串。
你也可以在正则之后添加+ 开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。

简单地说, 贪婪模式和占有模式相比, 贪婪模式会在只有部分匹配成功的条件下, 依次从多到少减少匹配成功部分模式的匹配数量, 将字符留给模式其他部分去匹配; 而占用模式则是占有所有能匹配成功部分, 绝不留给其他部分使用。

| 贪婪   | 懒惰    | 独占    |
|--------|---------|---------|
| X?     | X??     | X?+     |
| X*     | X*?     | X*+     |
| X+     | X+?     | X++     |
| X{n}   | X{n}?   | X{n}+   |
| X{n,}  | X{n,}?  | X{n,}+  |
| X{n,m} | X{n,m}? | X{n,m}+ |

贪婪型

```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>aava </tr>
}
```

勉强型

```java
String text = "a<tr>aava </tr>abb ";
String reg="<.+?>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // <tr>
  // </tr>
```

独占型
它和最大匹配一样，一直匹配所有的字符，直到文本的最后，但它不由原路返回。因此会一直匹配.+，不回溯，由此没法完成正则表达式的匹配，因此不打印任何东西

```java
String text = "a<tr>aava </tr>abb ";
String reg="<.++>";
Pattern p=Pattern.compile(reg);
Matcher matcher=p.matcher(text);
while(matcher.find()){
  System.out.println(matcher.group());
  // 不进行打印
}
```

String类的三个正则操作：
matches();
split();
replaceAll();

java.utils.regex包中包含以下三个类：

- Pattern 类：模式类，用于表达和陈述所要搜索模式的对象。
- Matcher 类：匹配器类 搜索的对象。
- PatternSyntaxException 类： 不合法的搜索模式时，抛出的异常。

# 注解

在项目开发中，注解的使用无处不在。注解的使用简化了代码，减少了程序员的工作量。本课程带领小伙伴们全面认识Java的注解，包括为什么使用注解、Java中的常见注解、注解的分类和如何自定义注解，最后通过一个实战案例来演示注解在实际项目中的应用。

# BIO、NIO与AIO

- BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。

- NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。

- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。

Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。
Java NIO: Channels and Buffers（通道和缓冲区）
标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
Java NIO: Non-blocking IO（非阻塞IO）
Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。
Java NIO: Selectors（选择器）
Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。

# java容器

为了方便编写出线程安全的程序，Java里面提供了一些线程安全类和并发工具，比如：同步容器、并发容器、阻塞队列、Synchronizer。

在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。

List、Set、Queue接口分别继承了Collection接口，分别代表数组、集合和队列这三大类容器。
Map本身是一个接口。

对于非线程安全的容器，比如ArrayList、LinkedList、HashMap，当出现多线程并发访问时，会出现问题。因此在编写程序时，必须要求程序员手动地在任何访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。
由此java提供了一系列的同步容器（使用了synchronized进行同步，只有一把锁，读写操作存在竞争问题，效率损失）：

- Vector、Stack、HashTable
- Collections类中提供的静态工厂方法创建的类
  Collections类是一个工具提供类，注意，它和Collection不同，Collection是一个顶层的接口。在Collections类中提供了大量的方法，比如对集合或者容器进行排序、查找等操作。最重要的是，在它里面提供了几个静态工厂方法来创建同步容器类

为了解决同步容器的性能问题，java提供了并发容器，在java.util.concurrent目录下。在了解并发容器时，需要搞清楚CAS。

>CAS是一种无锁的非阻塞算法。Compare and swap
大致思路是：先比较目标对象现值是否和旧值一致，如果一致，则更新对象为新值；如果不一致，则表明对象已经被其他线程修改，直接返回。

- ConcurrentHashMap 实现了HashTable的所有功能，线程安全，但却在检索元素时不需要锁定，因此效率更高。但是key，value不能允许null值出现。
- ConcurrentLinkedQueue
- CopyOnWriteArrayList 提供高效地读取操作，使用在`读多写少`的场景。CopyOnWriteArrayList读取操作不用加锁，且是安全的；写操作时，先copy一份原有数据数组，再对复制数据进行写入操作，最后将复制数据替换原有数据，从而保证写操作不影响读操作。存在内存占用问题，并且只能保证最终一致性，不能保证实时一致性
- ConcurrentSkipListMap（跳表）ConcurrentSkipListMap的实现就是实现了一个无锁版的跳表，主要是利用无锁的链表的实现来管理跳表底层，同样利用CAS来完成替换

当然，为了解决队列的阻塞问题，我们引入了阻塞队列。它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒，这是非阻塞队列需要实现的同步以及线程唤醒的问题）。这样提供了极大的方便性。

- ArrayBlockingQueue 基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。
- LinkedBlockingQueue 基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。
- PriorityBlockingQueue 以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。
- DelayQueue 基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

## HashMap

HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

Hashmap 不是同步的，如果多个线程同时访问一个 HashMap，而其中至少一个线程从结构上（指添加或者删除一个或多个映射关系的任何操作）修改了，则必须保持外部同步，以防止对映射进行意外的非同步访问。

HahMap就是数组和链表的结合体。

注意`遍历使用entry`效率高

![HashMap](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181011205122.png)

```java
HashMap<String, String> map = new HashMap<>();
map.put("K1", "V1");
map.put("K2", "V2");
map.put("K3", "V3");
```

- 新建一个 HashMap，默认大小为 16；
- 插入 <K1,V1> 键值对，先计算 K1 的 hashCode ，所在的桶下标1(假设)，插入
- 插入 <K2,V2> 键值对，先计算 K2 的 hashCode ，所在的桶下标2(假设)，插入
- 插入 <K3,V3> 键值对，先计算 K3 的 hashCode ，所在的桶下标2(假设)，插在 <K2,V2> 前面。

这里应该注意到两点

- hashcode的计算，通过key的hashCode经过`扰动函数处理`后得到hash值。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

- 链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头部。

- 当链表长度大于8时，需要将链表转换为红黑树。

查找需要分成两步进行：

- 计算键值对所在的桶；
- 在链表上顺序查找，时间复杂度显然和链表的长度成正比。

![结构](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181011205320.png)

### 红黑树

红黑树的存在就是为了解决二叉查找树的缺陷，因为二叉树在某些情况下会退化为一个线性结构。

![红黑树示意图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181127143319.png)

红黑树是一种自平衡的二叉查找树。红黑树从根到叶子的最长长度不会超过最短路径的2倍

红黑树的特点：
根节点总是黑色的；
每个叶子节点都是黑色的空节点（NIL节点）
每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（即相同的黑色高度）

### 并发访问HashMap的问题

体现在容量大于`总量 initialCapacity*负载因子 loadFactor`发生扩容时会出现环形链表从而导致死循环。由于hashmap非线程安全，扩容时如果多线程并发进行操作，则可能有两个线程分别操作新表和旧表，导致节点成环，查询时会形成死锁。
[循环链表，执行get操作，死循环](https://www.jianshu.com/p/1e9cf0ac07f4)

### HashMap扩容问题

HashMap具有扩容机制，当HashMap中元素的个数(size)超过临界值(threshold)时，会发生自动扩容。
`threshold=loadFactory*capacity`  loadFactory默认值是0.75。

所以，如果我们没有设置初始容量大小(initialCapacity)，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。

```java
Map<String, String> map = new HashMap<String, String>(1);//实际大小为2
```

上述代码虽然设置了初始容量为1，但是HashMap内部会处理采用第一个大于该数值的2的幂作为初始化容量。

当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？

关于这个值《阿里巴巴开发手册》有这么一个建议：
initialCapacity=(需要存储的个数/loadFactory)+1
如果无法确定大小，请设置为默认值16。

假如我们要存储7个数据，如果我们设置初始大小为7的话，经过JDK自己的运算后，会设置为8.那么`threshold=loadFactory*capacity=0.75*8=6`，此时7>6 会发生扩容。
如果我们考虑loadFactory使用公式，设置初始大小为10，经过JDK自己的运算后，会设置为16,`threshold=loadFactory*capacity=0.75*16=12`此时不会发生扩容。

以上的操作是一种用内存换性能的做法，真正使用的时候，要考虑到内存的影响。

## TreeMap

排好序的Map

## Hashtable(基本被淘汰)

- HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。
- Hashtable 方法是同步（加锁），而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，
- HashTable的key、value都不可以为null。此外，Hashtable中的映射不是有序的。

## ConcurrentHashMap

线程安全

ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。

注意当链表长度大于8时，需要将链表转为红黑树
1.8之后取消了ReentrantLock，改为synchronized+CAS来进行加锁

总的说来，在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。

## HashSet

HashSet的底层使用了HashMap来保存元素。 不允许存储重复元素，当重复时，进行覆盖。

```java
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
```

比较关键的就是这个 add() 方法。 可以看出它是将存放的对象当做了 HashMap 的健，value 都是相同的 PRESENT 。由于 HashMap 的 key 是不能重复的，所以每当有重复的值写入到 HashSet 时，value 会被覆盖，但 key 不会受到影响，这样就保证了 HashSet 中只能存放不重复的元素。

## TreeSet

是二叉树实现的，是排序顺序的，不允许放入null值。当需要排序的功能时，我们才使用TreeSet，而不考虑HashSet

## LinkedHashMap

具有顺序(双向链表)的HashMap，这里顺序可是设置为插入顺序(accessOrder为false，默认)，也可以设置为访问顺序(accessOrder为true)。
当根据访问顺序排序的时候，每次get都会将访问的值移动到链表的尾部，这样重复操作就能得到一个按照访问顺序排序的链表。

### LCU

LRU 缓存利用了这样的一种思想。LRU 是 Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU 缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用 LRU 缓存，我们能够提高系统的 performance。

要实现 LRU 缓存，我们首先要用到一个类 LinkedHashMap。

用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap 本身有一个方法用于判断是否需要移除最不常读取的数，但是，原始方法默认不需要移除（这里，LinkedHashMap 相当于一个linkedlist），所以，我们需要 override 这样一个方法，使得当缓存里存放的数据个数超过规定个数后，就把最不常用的移除掉。

## LinkedHashSet

具有顺序的HashSet，这里顺序可是设置为插入顺序，也可以设置为访问顺序。

## ArrayList

可变长动态数组，是不安全的。

```java
Collections.synchronizedList(); //得到一个线程安全的 ArrayList。
```

`ArrayList`实现了`List` 和`RandomAccess`接口， 可以随机访问。
它在add()时，会首先进行扩容校验，然后将数据插入到尾部，并使size+1。
它的add(index,e)时，也会进行扩容校验，然后复制数组，将index位置插入数据，并将后面的数据向后移动。

由此可见 ArrayList 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。

同时由于ArrayList是基于动态数组实现的，并不是所有的空间都被使用。因此需要防止被自动序列化。从而ArrayList 自定义了序列化与反序列化，只序列化了使用的要素。

```java
transient Object[] elementData;
```

## CopyOnWriteArrayList

安全的ArrayList。
写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。
写操作需要加锁，防止并发写入时导致写入数据丢失。
写操作结束之后需要把原始数组指向新的复制数组。

CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

但是 CopyOnWriteArrayList 有其缺陷：

内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。
所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景

## ConcurrentLinkedQueue

ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全。 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景。

## BlockingQueue

阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。

### ArrayBlockingQueue

ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。

### LinkedBlockingQueue

底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE。

### PriorityBlockingQueue

PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。

PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）

简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。

## ConcurrentSkipListMap

线程安全的跳表。我们这里先解释一下`跳表`的含义。

对于一链表，及时他是有序的，我们仍然需要顺序遍历链表来查找某个数据。跳表就不一样了，跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。

跳表的本质是维护了多个链表，并且链表是有层级关系。最低层的链表维护了跳表内所有的元素，每一级上层链表都是下级链表的子集。
注意跳表本身是有序的，因此在查找时，我们首先从高级链表查询，一旦被查找的元素的值大于当前链表的值，就到下一层链表查询。
下图是在表中查找18的过程。

![跳表](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181217111327.jpg)

跳表是一种典型的`空间换取时间`的算法

## LinkedList

双向链表实现的List，它的插入和删除更加有效，只是移动指针。
在查询时，需要遍历查询，效率较低。当index离链表头较近，就从节点头部遍历，否则就从尾部开始遍历。使用空间(双向链表)来换取时间

## Vecotr

与ArrayList使用一致，是可变长数组 但是是线程安全的同步容器。在添加元素的时候使用`synchronized`进行同步写数据。

## PriorityQueue

优先队列（本质是堆实现的），队列中的元素是有优先级的，优先级最高的元素就排在队列的第一位，当我们从队列中去取的是，得到的是优先级最高的那个元素。这个优先级我们是可以自己定义的，比如值最大的，优先级最高，也可以定义成值最小的，优先级最高，甚至可以指定比较某个具体的对象的某个属性，比如学生的学号，年龄这种的。

# 接口default方法的重要性

添加新方法而不需要原本已经存在的实现该接口的类做任何改变（甚至不需要重新编译）就可以使用该新版本的接口。

# 如何理解Java程序使用Unicode字符集编写

Java字符和字符串存在于以下几个地方：

Java源码文件，*.java，可以是任意字符编码，如GBK，UTF-8
Class文件，*.class，采用的是一种改进的UTF-8编码（Modified UTF-8）
JVM，内存中使用UTF-16编码

```java
String s = String.valueOf("中文");
byte[] defaultValue=s.getBytes();//Charset.defaultCharset()为utf-8(idea设置为)     e4 b8 ad e6 96 87
byte[] unicode = s.getBytes("unicode");//unicode-big     fe ff 4e 2d 65 87
byte[] utf_8 = s.getBytes("utf-8");//                    e4 b8 ad e6 96 87
byte[] GBK = s.getBytes("GBK");//                        d6 d0 ce c4
System.out.println(encodeHex(defaultValue));
```

注意这里String s存储的Value值是 [45,78,-121,101]
但是获取的unicode是[-2,-1,78,45,101,-121] 是feff 默认的是Big的形式

# 接口和抽象类

## 抽象类

抽象类用于描述对象的行为，比如动物，动物会吃东西，但是动物具体会有是什么样的吃的行为，只有具体的动物类，如Dog，Cat才会有具体的行为。
抽象类是实现多态的一种机制。

```java
Animal cat=new Cat();
Animal dog=new Dog();
cat.eat();
dog.eat();
```

1.抽象类不可以被实列化
2.抽象类的抽象方法必须被子类实现，非抽象方法自身实现
3.子类的抽象方法不可以和父类的抽象方法同名
4.子类不需要实现父类的所有方法（可以不实现父类的非抽象方法）

## 接口类

接口是通过`interface`来实现的，因此也是不能实例化的。接口的实现类必须实现接口中定义的方法(除了接口定义的default或者static方法)，java不允许多继承，但可以实现多个接口。

1.可以通过instanceOf来判别一个类是否实现了某个接口，`if(obj instanceOf className) {doSomething()}`

## 区别和联系

### 语法层次

抽象类的定义：

```java
// 抽象类中可以包含抽象方法与非抽象方法（必须给出实现）
public abstract class Demo
{
    public String name="demo";//抽象类可以拥有任意范围的成员数据，
    abstract void foo1();
    void foo2(){
        //实现
    }
}
```

接口的定义：

```java
interface Demo
{
    // 接口中的方法自动转为public abstract
    void foo1();
    default void foo2(){
    }
    static void foo3(){
    }
}
```

在以前的版本中，接口中是不能包含具体的实现的，但是在新版的java中为了更方便的使用接口(因为接口可以多继承的优点)，允许在接口中定义static和default方法。

### 设计层次

从设计的层面来说，具有如下的不同点

1.`抽象层次不同`。抽象类是对类的抽象，接口是对行为的抽象。抽象类是是对类整体进行抽象，包括属性和行为。但是接口只是对类的局部(行为)进行抽象。

2.`应用情景不同`。抽象类描述的都是具有相似特点的类，而接口可以横跨不同的类。
抽象类包含着继承关系，说明了父类和派生类有一定的关系，及(派生类 is a kind of 父类)
接口只是说明，你实现了这种接口，你就必须会这个接口定义的方法。