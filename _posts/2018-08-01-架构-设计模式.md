---
layout:     post
title:      设计模式
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# 设计模式

写出优雅代码的根本在于你对真实世界的合理抽象，就是在于 对面向对象设计思想的理解。
隔离不变与变化

# 原则

设计模式的核心思想是六个基本原则，其那么多的设计模式都是基于这6个原则产生的一系列模板。
而这些原则往往就设计到两个元素：接口，类，以及他们之间的关系。
对于接口：考虑 **分隔原则**
对于类的设计：对于类的本身，需要考虑 **单一职责**；对于类的继承，要考虑 **里氏替换原则** 与 **开闭原则**，减少子类对父类的影响
对于协作关系的设计：在做框架设计时，接口之间发生联系，要考虑 **依赖倒置原则**；当一个类与其他类发生调用关系时，利用中间者来转发调用关系( **迪米特法则** )

- 依赖倒置原则－Dependency Inversion Principle (DIP) 

在高层模块和低层模块之间，引入一个抽象接口层。抽象接口层是对低层模块的抽象，低层模块继承或者实现该抽象接口。
由此，高层模块不依赖低层模块， 低层模块依赖抽象定义
High Level Classes（高层模块） --> Abstraction Layer（抽象接口层） --> Low Level Classes（低层模块）

模块之间的依赖是通过抽象产生,实现类之间不发生直接的依赖关系.
接口或者抽象类不依赖实现类,实现类依赖于接口或者抽象类.

- 里氏替换原则－Liskov Substitution Principle (LSP)

子类可以替换父类，并出现在父类能够出现的任何地方

- 接口分隔原则－Interface Segregation Principle (ISP)

最小接口原则，一个接口的某个方法未被使用的话，则说明该接口过胖，应该将其分割为多个功能专一的接口。
这就要求在设计接口的时候，使用多个专门的接口代替单一的胖接口

- 单一职责原则－Single Responsibility Principle (SRP)

问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。
因此只能让一个类有且仅有一个职责。
换一句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。
>注意:单一职责原则不是只要求我们为类定义一个职责,而是提醒我们在一个类中尽量让类负载少的职责,从而保证对象具有高内聚与细粒度.
应用：分层架构就是单一职责的最佳体现，JavaEE框架就将系统根据职责的内聚给分为了不同层：

```txt
Presentation:表现层
Business:业务层
persistence: 持久层
Database:数据层
```

- 开闭原则－The Open-Closed Principle (OCP)

可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。

- A.对扩展开放（open）:通过扩展增加功能，实现了功能上的扩展性。

- B.对修改关闭（closed）:模块内部代码不允许修改，该模块修改关闭，保证了功能上的稳定性。

- 迪米特法则－The Law of Demeter (OCP)

对象和对象之间关联应该尽量少，避免千丝万缕的关系。尽量降低类与类之间的耦合，以防止一个类发生改变，另一个依赖的类也受到影响。
1)只同你直接的朋友们通信
2)不要跟陌生人说话
3)每一个软件单位对其他的单位都只有最少的了解,这些了解仅局限于那些与本单位密切相关的软件单位.

# 创造型模式

提供了一种在创建对象的同时，隐藏创建逻辑的方式。大大灵活了创建对象时的灵活性。

## 工厂模式和抽象工厂模式

用于在不同的条件下创建不同的实例，解决接口选择问题。
通过定义接口，让工厂类(将实际创建工作推迟到具体工厂类)实现工厂接口，让调用者自己决定实例化哪一个工厂类，返回的是一个抽象的工厂产品实例。

```java
Facatory aFactory=new AFactory();//AFactory继承接口Facatory，在具体实现的工厂类中创建对象
AWord a=(AWord)aFactory.getWord();//Aword继承Word
```

（1）对于某个产品，调用者清楚地知道应该使用哪个具体的工厂来服务，实例化该具体工厂，生产出具体的产品来；
（2）只是需要一种产品，而不想知道也不需要知道工厂是如何生产出来的，自需要知道具体对应的工厂就行。

## 单例模式(Singleton)

保证一个类仅有一个实例，而且会自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。

对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

单例模式一般有5种写法：
1.饿汉模式，先把单例进行实例化，获取的时候通过静态方法直接获取即可。缺点是类加载后就完成了类的实例化，浪费部分空间。
2.饱汉模式，先把单例置为null，然后通过静态方法获取单例时再进行实例化，但是可能有多线程同时进行实例化，会出现并发问题。
3.synchronized volatile实现。
4.使用静态内部类来实现，静态内部类只在被使用的时候才进行初始化，所以在内部类中进行单例的实例化，只有用到的时候才会运行实例化代码。然后外部类再通过静态方法返回静态内部类的单例即可。
5.枚举类，枚举类的底层实现其实也是内部类。枚举类确保每个类对象在全局是唯一的。所以保证它是单例，这个方法是最简单的。

### 饿汉式单例(立即加载)

饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。Singleton1的唯一实例只能通过getInstance()来获取。

```java
// 饿汉式单例
public class Singleton1 {
    // 私有构造
    private Singleton1() {}

    private static Singleton1 single = new Singleton1();

    // 静态工厂方法
    public static Singleton1 getInstance() {
        return single;
    }
}
```

### 懒汉式单例（延迟加载方式）

```java
// 懒汉式单例
public class Singleton2 {

    // 私有构造
    private Singleton2() {}

    private static Singleton2 single = null;

    public static Singleton2 getInstance() {
        if(single == null){
            single = new Singleton2();
        }
        return single;
    }
}
```

上的方法，虽然用延迟加载方式实现了单列模式，但是在多线程环境下会出现一些问题，比如：

1.有序性问题，
`single =new Singleton2()`这段代码本质上是三步

- 分配内存空间
- 初始化对象
- 将对象指向分配的内存地址

如果single不用`volatile`修饰的话，就无法按顺序执行以上命令，就会存在第三步在第二步之前被执行。导致某个线程会拿到没有初始化的单例对象的地址，以至于使用报错

2.多个single对象的建立
如果getInstance()不用`synchronized`修饰的话，就会存在多个single的创建。

多线程的单例模式请参考：

```java
public class Singleton3 {
    // 私有构造
    private Singleton3() {}

    private static volatile Singleton3 single = null;

    public static Singleton3 getInstance() {
        // 等同于 synchronized public static Singleton3 getInstance()
        synchronized(Singleton3.class){
          // 注意：里面的判断是一定要加的，否则出现线程安全问题
            if(single == null){
                single = new Singleton3();
            }
        }
        return single;
    }
}
```

上面的代码对类进行同步加锁，但是运行效率低，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。
因此我们考虑加入双重检查

```java
public class Singleton {
        private static volatile Singleton singleton=null;

        private Singleton() {
        }

        public static Singleton getInstance() {
            if (singleton == null) {
                synchronized (Singleton.class) {
                    if (singleton == null) {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }

    }
```

使用双重检查进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率。

### 静态内部类方式

静态内部实现的单例是懒加载的且线程安全。
只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}

```

## 建造者模式(Builder)

将复杂的对象构建与其具体的细节分离，以链式的方法来创造对象。
>类的内部包含一个类的创建静态类，每次用这个静态类再次调用类的构造函数,具体可以参考lombok的Builder实现

## 原型模式(Prototype)

直接创建对象代价较大，采用原型模式，用原型实例指定创建对象的种类，在通过 **拷贝** 原型获取新的对象。
>浅Clone和深clone实现

# 结构性模式

这些设计模式关注类和对象的组合。

## 适配器模式(Adapter)

使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。把鸭包装为鸡，当鸡用。

## 装饰器模式(Decorator)

保持接口，增强性能：修饰类继承被修饰对象的抽象父类，依赖被修饰对象的实例（被修饰对象依赖注入），以实现接口扩展

## 代理模式(Proxy)

为其他对象提供一种代理以控制对这个对象的访问：增加中间层（代理层），代理类与底层实现类实现共同接口，并创建底层实现类对象（底层实现类对象依赖注入代理类），以便向外界提供功能接口

## 外观模式(Facade)-门面模式

在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。即封装底层实现，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的高层接口

门面模式(Facade Pattern),其核心就是，外部和一个子系统的通信必须通过一个统一的外观对象进行，这样使得子系统更易于使用。

![外观模式](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181205143100.jpg)

## 桥接模式(Bridge)

两个维度独立变化，依赖方式实现抽象与实现分离：需要一个作为桥接的接口/抽象类，多个角度的实现类依赖注入到抽象类，使它们在抽象层建立一个关联关系

## 过滤器模式(Filter)

使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来

## 组合模式(Composite)

用户对单个对象和组合对象的使用具有一致性的统一接口

## 享元模式(Flyweight)

享元工厂类控制；HashMap实现缓冲池重用现有的同类对象，如果未找到匹配的对象，则创建新对象

# 行为型模式

关注对象之间的通信。

## 策略模式(Strategy)

策略对象依赖注入到context对象，context对象根据它的策略改变而改变它的相关行为(可通过调用内部的策略对象实现相应的具体策略行为

## 模板方法模式(Template)

将这些通用算法抽象出来，在一个抽象类中公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

## 观察者模式(Observer)

一对多的依赖关系，在观察目标类里有一个 ArrayList 存放观察者们。当观察目标对象的状态发生改变，所有依赖于它的观察者都将得到通知，使这些观察者能够自动更新（即使用推送方式）

## 迭代子模式(Iterator)

集合中含有迭代器：分离了集合对象的遍历行为，抽象出一个迭代器类来负责，无须暴露该对象的内部表示

## 责任链模式(Chain of Responsibility)

拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

## 命令模式(Command)

将"行为请求者"与"行为实现者"解耦：调用者依赖命令，命令依赖接收者，调用者Invoker→命令Command→接收者Receiver

## 备忘录模式(Memento)

通过一个备忘录类专门存储对象状态。客户通过备忘录管理类管理备忘录类。

## 状态模式(State)

状态对象依赖注入到context对象，context对象根据它的状态改变而改变它的相关行为(可通过调用内部的状态对象实现相应的具体行为)

## 访问者模式(Visitor)

访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。

## 中介者模式(Mediator)

对象与对象之间存在大量的关联关系，将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散，可以独立地改变它们之间的交互

## 解释器模式

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子

## 空对象模式

创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。不要为了屏蔽null而使用空对象，应保持用null，远比用非null的值来替代“无值”要好。
