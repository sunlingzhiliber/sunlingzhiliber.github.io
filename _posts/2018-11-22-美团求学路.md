---
layout:     post
title:      美团求学路
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: 招聘
---

美团求学路？

# 初级

## 1.&& & | ||

&和| 可以做位运算符

&和| 也可以做逻辑运算符，当作逻辑运算符时和&& ||的区别是 &和|是左右均会计算，而&&和||是从左到右计算，可能存在右侧不计算的问题

## 2.Forward和Redirect

转发是服务器端行为，重定向是客户端行为。

- 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
- 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.
- 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等
- 从效率来说: forward:高. redirect:低.

## 3.在浏览器中输入URL会发生什么

>尽可能具体，不遗漏任何细节。

以www.baidu.com为例子：

### 按下字母w

大致分为两个部分，一个部分涉及到了计算机硬件和计算机底层的内容。另一部分是浏览器自身的工作。

#### 计算机做了什么

在这个时刻，一个专用于`w`的电流回路被直接地或者通过电容器间接地闭合了，使得量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值119。键盘控制器在得到码值之后，将其编码，用于之后的传输。
然后这个'w'是如何绘制到屏幕中搜素框内的呢？操作系统内部维护了一个unsignedchar类型点阵数组fontdata_8x16[]来实现所有ASCII码字符的点阵形状，每一个字符点阵由16个元素构成。对于点阵，他的首地址索引值就是字符的ASCII值，即可根据字的ASCII码值得到字符点阵首地址，

- 首地址为：fontdata_8x16[119*16]的地址。
- 比如字符'w' 他的首地址就是fontdata_8x16[1040]，然后往后面取16个元素。
- 16*16个像素进行描绘。

#### 浏览器做了什么

按下某个字母的时候，浏览器接收这个信息，会触发自动完成机制。
浏览器会根据一定的算法，优先考虑你的搜索历史和书签的内容给出建议。并且你的每次按键都会让给出的建议更加确定。

### 按下回车键

#### 解析URL

当协议或主机名不合法时，浏览器会将地址栏输入的文字传给默认的搜索引擎。

#### urlencode

urlencode实际上是为了在url中支持一些非ascii字符而采用的一种对url进行编码的式。
比如url：`http://localhost:8080/test?id=孙菱志`
url是不支持非ascii字符的，所以就要进行urlencode，而一般浏览器帮我们做这件事(不同浏览器默认编码方式不同)。
编码后的url：`http://localhost:8080/testid=%E5%AD%99%E8%8F%B1%E5%BF%97`。
我们要知道每个操作系统，每个浏览器，每个用户都可以对编码方式进行选择，如果不编码方式进行控制，那么就会存在不同的编码方式。
因此我们在代码中，建议利用js代码对URL进行编码，然后在进行提交。这个时候ascii围外的字符也直接传输。
那么在服务器端接受到数据了 如何进行解码呢？
以tomcat为例，tomcat会自己按照缺省iso-8859-1 对URL进行解码。如果对应的编码码方式不一致，就会导致乱码问题。
在程序里我们可以先以iso-8869-1还原字节码，在使用指定的编码，来获取正确的字段。

```java
String id=new String(req.getParameter("id".getBytes("io-8859-1")),"浏器指定的编码方式")
```

当然，你也可以直接修改tomcat的解码方式为浏览器指定的编码方式。

### 检查HSTS列表

- 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站
- 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送
- 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

### DHCP

如果主机一开没有IP地址，需要DHCP配置IP地址、子网掩码和DNS服务器的IP地址，以及默认网关路由器的地址。

### DNS查询

- 浏览器检查域名是否存在于浏览器缓存之中。(chrome://net-internals/#dns)
- 如果浏览器缓存中没有，就会调用`gethostbyname`库函数进行查询，检查该域名是否存在本地Hosts中(C:\Windows\System32\drivers\etc\hosts)。
- 如果 `gethostbyname`没找到，他就会发送一个UDP包到DNS服务器，DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。
- 查询DNS服务器的MAC地址，如果DNS和主机位于一个子网，直接进行ARP查询(IP地址与MAC地址的转换)，如果不在一个子网，需要对默认网关(gateway)进行递归ARP查询。
- 找到DNS服务器，发送DNS请求，获取目标域名的IP地址，并放入缓存中。

### TCP连接

获取服务器IP后，我们需要构建TCP连接，为了构建TCP连接，我们需要知道本机IP 本机端口 服务器IP 和服务器端口。HTTP服务的端口是80。

- 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)
- TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。
- 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

这个时候经过TCP的 三次握手连接 之后，我们就可以发送HTTP请求了。

### HTTP服务器请求的处理

HTTP请求通过了千山万水，多个路由器(IP数据包在路由器之间转发的使用，又会使用到OPSF协议)，终于抵达服务器，这个时候服务器就开始着手处理了。

我们这里以Nginx继续下面的故事：

- 对于HTTP请求，Nginx读取后，需要判断是静态请求呢还是动态请求。如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。
- 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。

![负载均衡](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115534.png)

例如Ngnix支持这么几种：

| 轮询               | 默认方式        |
|--------------------|-----------------|
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

由此我们最后的连接情况是这样的。
![链接](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115553.png)

到了应用服务器Tomcat，我们又做了些什么呢？一个HTTP request一个servlet 一个controller 一个service 最终返回一个HTTP response。
当response返回到Ngnix，再返回到浏览器后，我们该干嘛呢？

### 浏览器

通常我们的这个response是一个HTML页面。那么我们就开始准备显示这个页面。这个页面中可能包含了大量的静态资源，因此我们又会重复上面的操作，进行静态资源的访问。当然，这里的访问，会由浏览器去创建多个TCP连接，并行的去下载。
注意静态资源在返回时，服务器会告诉浏览器这些文件的过期时间(Cache-Control或者Expire),这是浏览器就会进行缓存。当第二次请求的时候就从缓存中获取。
如果过期了，浏览器会询问服务器是否更改，（依据是依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not
Modified），就继续使用缓存，反之将最新文件返回到浏览器。

### 页面渲染

在得到HTML,CSS,JS之后，就由浏览器去绘制页面即可。

## 4.TCP 三次握手和四次挥手

请参考计算机网络中的相关知识。

## 5.IP地址与MAC地址的区别

IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。

他们两者可以通过ARP协议进行转换。

## 6.索引

索引是对数据库表中一个或多个列的值进行排序(无序变为有序)的结构。索引具有以下的优点：

- 通过建立唯一性索引，可以保证数据库表中的每一行数据的唯一性。
- 建立索引，可以大大加快数据的检索速度(大大减少检索的数据量)
- 帮助服务器避免排序
- 将随机IO变为顺序IO
- 可以加速表与表之间的链接。

虽然索引具有一系列的优点，但是我们并不能对表中的每一列创建一个索引。

- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 7.进程和线程

线程与进程相似，但线程是一个比进程更小的执行单位。
一个进程在其执行的过程中可以产生多个线程。
与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。
总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。

### 进程之间的通信

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
2. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
3. 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
4. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
5. 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
6. 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。

### 线程之间的通信

线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。

1. 锁机制

互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。
读写锁：允许多个线程同时读共享数据，而对写操作互斥。
条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

2、信号量机制：包括无名线程信号量与有名线程信号量

3、信号机制：类似于进程间的信号处理。

## 8.单例模式

请参考设计模式

## 9.SpringBean

在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。

Spring bean默认是单例的,这些单例Bean在多线程程序下如何保证线程安全呢？ 例如对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。

## 12.SpringAOP和SpringIOC

IOC: 控制反转也叫依赖注入。IOC利用java反射机制，AOP利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。

AOP： 面向切面编程。（Aspect-Oriented Programming） 。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。

# 进阶

## 消息队列

消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。

![消息队列](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126215734.png)

特点：

- 异步性，将耗时的同步操作，通过以发送消息的方式，进行了异步化处理。减少了同步等待的时间
- 松耦合，消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。
- 分布式，通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性
- 可靠性，消息队列一般会把接收到的消息存储到本地硬盘上，这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。

你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。

### 消息队列的好处

1.通过异步处理提高系统性能

![使用消息队列](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181126214731.jpg)

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。

但是我们注意，因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。
因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。

2.降低系统耦合性

我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性就会更好一些。

我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：

![生产者消费者模式](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181126220210.jpg)

上图中利用，消息队列，生产者和消费者并没有直接耦合。消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。这就类似于你写信`对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。`

### 消息队列的缺点

- 系统可用性降低：在加入MQ之后，你需要考虑消息丢失或者MQ宕机的情形。
- 系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
- 一致性问题： 会导致数据不一致的问题。

### 常见问题

1. 引入消息队列之后如何保证高可用性
2. 如何保证消息不被重复消费呢？
3. 如何保证消息的可靠性传输（如何处理消息丢失的问题）？
4. 我该怎么保证从消息队列里拿到的数据按顺序执行？
5. 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
6. 如果让你来开发一个消息队列中间件，你会怎么设计架构？

## 集合

### RandomAccess接口

```java
public interface RandomAccess {
}
```

查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。
标识什么？ 标识实现这个接口的类具有随机访问功能。
ArrayList具有随机访问的功能，因此需要实现RandomAccess以表示其具有随机访问的能力，而不是说实现了RandomAccess接口，就具有了随机访问的能力。

这里注意哈：

- 实现了RandomAccess接口的list，优先选择普通for循环，其次为foreach循环
- 未实现RandomAccess接口的list，优先选择iterator遍历(foreach的遍历底层也是iterator实现)，大size的数据，千万不要使用普通for循环。

# 终极
