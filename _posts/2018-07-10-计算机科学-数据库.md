---
layout:     post
title:      计算机科学
subtitle:   数据库
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 数据库
---

数据库相关知识点

# 持久层

我们经常有持久层这个说法，那么持久层是什么呢？我们先来谈谈 数据的`持久性`，持久性是数据的一个属性，其确保即使实在应用的生命周期以外数据仍是可用的。
对于Java而言，持久性确保了即使是在创建对象的应用停止执行之后对象的状态仍是可访问的。

而我们如何保证持久性呢，有两种手段，一个是将数据保存在文件中，一个是将数据保存到数据库中。

那么持久层的概念就油然产生了，分离了业务逻辑和数据库代码的层面即使持久层。

持久层封装了存储和检索数据库中的数据的方式。

# JDBC

JDBC(JAVA DataBase Connectivity),通过JDBC我们可以在java程序和数据库之间建立链接，并通过java程序来操作数据库中的数据。

JDBC(是一系列的接口)不能直接访问数据库，必须依赖数据库厂商提供的JDBC驱动程序。JDBC为用户完成了以下三步工作：

1.同数据库建立链接
2.向数据库发送SQL语句
3.处理从数据库返回的数据

JDBC API使用SQL语句来完成创建（create）、读取（read）、更新（update）和删除（delete）（CRUD）操作。

这类代码还在很大程度上依赖于SQL，而SQL并非是跨数据库的标准；这使得从一种数据库移植到另一种数据库变得困难起来。

这就有了ORM的说法。

# ORM

ORM(对象关系映射)，对象和数据库中的表一一对应，存在一个直接的映射关系。

ORM是一种透明地把应用对象持久到关系数据库中的表的技术。
ORM的行为就像是一个虚拟的数据库，对用户隐藏了底层的数据库架构。
ORM提供功能来执行完整的CRUD操作并鼓励面向对象的查询。

iBATIS、Hibernate是用于把数据持久到关系数据库中的的机制

## iBATIS

iBATIS不提供完整的ORM解决方案，也不提供任何的对象和关系模型的直接映射。
不过，iBATIS给你提供了对查询的全面控制权。
以SQL为中心，要求全面地控制SQL,将java对象映射到SQL查询的结果上。

## Hibernate

Hibernate提供了一个完整的ORM解决方案，但不提供对查询的控制权

对于不太熟悉SQL的面向对象编程者来说，Hibernate是最佳选择。

Hibernate直接把Java对象映射到数据库表上，

# JPA

JPA(Java persistence API),是ORM的一种规范，定义一组必须实现的接口。

上文的Hibernate就是JPA规范的一种实现。

# 事务

>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)

一个数据库事务通常包含对数据库进行读或写的一个操作序列。。它的存在包含有以下两个目的：

- 1.为数据库操作提供了一个从失败中回复到正常状态的方法，同时提供了数据库即使在异常状态下仍保持一致性的方法。
- 2.当多个应用程序并发访问数据库时，能够在这些应用程序中提供一个隔离的方法，以防止彼此操作互相干扰。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。 

## 特性

并非所有的对数据库的操作都被称作数据库事务。事务应当满足4个属性：原子性、一致性、隔离性以及持久性，这四个属性通常称之为ACID特性。
>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。

## 事务隔离

隔离性表示一个事务的修改结果在什么时间能够被其他事务看到，隔离性定义了不同的隔离级别，

- Read uncommitted
- Read committed  
- Repeatable reads
- Serializable

[请参考](http://www.hollischuang.com/archives/943)

## MVCC(Multi Version Concurrency Control)

隔离级别依次增强，但是导致的问题是并发能力的减弱。各种数据库厂商会对各个隔离级别进行实现。和Java中的多线程问题相同，数据库通常使用锁来实现隔离性。

最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。这就是MVCC（Multi Version Concurrency Control）

# 乐观锁、悲观锁、共享锁、排它锁

## 乐观锁

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

## 悲观锁

悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

在数据库中，悲观锁的流程如下：
>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。

### 共享锁

共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。

### 排它锁

排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。

# 范式

# 索引

创建索引，可以大大加快数据的检索速度，帮助服务器避免了排序，将随机IO变成了顺序IO。

但是我们却不能为每一个数据都进行索引的建立，因为索引的创建和维护都需要耗费掉资源，这里包括计算资源和空间资源。

索引的本质是将无序的数据变成相对有序的数据。

# ORM

# MyBatis

以SQL为中心，要求全面地控制SQL。
