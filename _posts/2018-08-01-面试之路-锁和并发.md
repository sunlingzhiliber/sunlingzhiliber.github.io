---
layout:     post
title:      锁和并发
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---
在JDK中，JAVA语言为了维持顺序内部的顺序化语义，也就是为了保证程序的最终运行结果需要和在单线程严格意义的顺序化环境下执行的结果一致，程序指令的执行顺序有可能和代码的顺序不一致，这个过程就称之为指令的重排序。指令重排序的意义在于：JVM能根据处理器的特性，充分利用多级缓存，多核等进行适当的指令重排序，使程序在保证业务运行的同时，充分利用CPU的执行特点，最大的发挥机器的性能！

从java源代码到最终执行的指令序列，会经过一下的三种重排序：

> 源代码->编译器优化重排序->指令级并行重排序->内存系统重排序->最终执行的指令序列




为了解决此类额外难题，Java存储模型引入了happens-Before发则，确保并发情况下的数据正确性！通俗的说就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程中），那么A/B必须满足happens-before发则！

在说happens-before发则之前我们还得先看另外一个概念：在Java中还有一个概念叫JMMA（Java Memory Medel Action）：Java模型动作。一个Action包含：编写读、变量写、监视器加锁、释放锁、线程启动(start)、线程等待(join)。关于锁我们后续会详细介绍。

说了这么多，那究竟什么是happens-before发则呢？完整的发则如下

（1）同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。

（2）对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。

（3）对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。

（4）Thread.start()的调用会happens-before于启动线程里面的动作。

（5）Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。

（6）一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。

（7）一个对象构造函数的结束happens-before与该对象的finalizer的开始

（8）如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。


# 并发的三个概念

1. 原子性
   即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

   在java中，对基本数据类型的变量的读取和赋值操作都是原子性操作，即这些操作是不可中断的。Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
2. 可见性
   可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

   Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
   
3. 有序性
   有序性：即程序执行的顺序按照代码的先后顺序执行。

   在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。