# 路由器和交换机的区别

工作层次不同：交换机主要工作在数据链路层（第二层）路由器工作在网络层（第三层）。
转发依据不同：交换机转发所依据的对象时：MAC地址。（物理地址）
路由转发所依据的对象是：IP地址。（网络地址）
主要功能不同：交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。
身份不同：交换机是看门大爷，路由是邮差。

# IP地址与MAC地址的区别

IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。

他们两者可以通过ARP协议进行转换。

# 在浏览器中输入URL会发生什么


>尽可能具体，不遗漏任何细节。

以www.baidu.com为例子：

## 按下字母w

大致分为两个部分，一个部分涉及到了计算机硬件和计算机底层的内容。另一部分是浏览器自身的工作。

### 计算机做了什么

在这个时刻，一个专用于`w`的电流回路被直接地或者通过电容器间接地闭合了，使得量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值119。键盘控制器在得到码值之后，将其编码，用于之后的传输。
然后这个'w'是如何绘制到屏幕中搜素框内的呢？操作系统内部维护了一个unsignedchar类型点阵数组fontdata_8x16[]来实现所有ASCII码字符的点阵形状，每一个字符点阵由16个元素构成。对于点阵，他的首地址索引值就是字符的ASCII值，即可根据字的ASCII码值得到字符点阵首地址，

- 首地址为：fontdata_8x16[119*16]的地址。
- 比如字符'w' 他的首地址就是fontdata_8x16[1040]，然后往后面取16个元素。
- 16*16个像素进行描绘。

### 浏览器做了什么

按下某个字母的时候，浏览器接收这个信息，会触发自动完成机制。
浏览器会根据一定的算法，优先考虑你的搜索历史和书签的内容给出建议。并且你的每次按键都会让给出的建议更加确定。

## 按下回车键

### 解析URL

当协议或主机名不合法时，浏览器会将地址栏输入的文字传给默认的搜索引擎。

### urlencode

urlencode实际上是为了在url中支持一些非ascii字符而采用的一种对url进行编码的式。
比如url：`http://localhost:8080/test?id=孙菱志`
url是不支持非ascii字符的，所以就要进行urlencode，而一般浏览器帮我们做这件事(不同浏览器默认编码方式不同)。
编码后的url：`http://localhost:8080/testid=%E5%AD%99%E8%8F%B1%E5%BF%97`。
我们要知道每个操作系统，每个浏览器，每个用户都可以对编码方式进行选择，如果不编码方式进行控制，那么就会存在不同的编码方式。
因此我们在代码中，建议利用js代码对URL进行编码，然后在进行提交。这个时候ascii围外的字符也直接传输。
那么在服务器端接受到数据了 如何进行解码呢？
以tomcat为例，tomcat会自己按照缺省iso-8859-1 对URL进行解码。如果对应的编码码方式不一致，就会导致乱码问题。
在程序里我们可以先以iso-8869-1还原字节码，在使用指定的编码，来获取正确的字段。

```java
String id=new String(req.getParameter("id".getBytes("io-8859-1")),"浏器指定的编码方式")
```

当然，你也可以直接修改tomcat的解码方式为浏览器指定的编码方式。

## 检查HSTS列表

- 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站
- 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送
- 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

## DHCP

如果主机一开没有IP地址，需要DHCP配置IP地址、子网掩码和DNS服务器的IP地址，以及默认网关路由器的地址。

## DNS查询

- 浏览器检查域名是否存在于浏览器缓存之中。(chrome://net-internals/#dns)
- 如果浏览器缓存中没有，就会调用`gethostbyname`库函数进行查询，检查该域名是否存在本地Hosts中(C:\Windows\System32\drivers\etc\hosts)。
- 如果 `gethostbyname`没找到，他就会发送一个UDP包到DNS服务器，DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。
- 查询DNS服务器的MAC地址，如果DNS和主机位于一个子网，直接进行ARP查询(IP地址与MAC地址的转换)，如果不在一个子网，需要对默认网关(gateway)进行递归ARP查询。
- 找到DNS服务器，发送DNS请求，获取目标域名的IP地址，并放入缓存中。

## TCP连接

获取服务器IP后，我们需要构建TCP连接，为了构建TCP连接，我们需要知道本机IP 本机端口 服务器IP 和服务器端口。HTTP服务的端口是80。

- 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)
- TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。
- 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

这个时候经过TCP的 三次握手连接 之后，我们就可以发送HTTP请求了。

## HTTP服务器请求的处理

HTTP请求通过了千山万水，多个路由器(IP数据包在路由器之间转发的使用，又会使用到OPSF协议)，终于抵达服务器，这个时候服务器就开始着手处理了。

我们这里以Nginx继续下面的故事：

- 对于HTTP请求，Nginx读取后，需要判断是静态请求呢还是动态请求。如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。
- 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。

![负载均衡](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115534.png)

例如Ngnix支持这么几种：

| 轮询               | 默认方式        |
|--------------------|-----------------|
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

由此我们最后的连接情况是这样的。
![链接](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20180928115553.png)

到了应用服务器Tomcat，我们又做了些什么呢？一个HTTP request一个servlet 一个controller 一个service 最终返回一个HTTP response。
当response返回到Ngnix，再返回到浏览器后，我们该干嘛呢？

## 浏览器

通常我们的这个response是一个HTML页面。那么我们就开始准备显示这个页面。这个页面中可能包含了大量的静态资源，因此我们又会重复上面的操作，进行静态资源的访问。当然，这里的访问，会由浏览器去创建多个TCP连接，并行的去下载。
注意静态资源在返回时，服务器会告诉浏览器这些文件的过期时间(Cache-Control或者Expire),这是浏览器就会进行缓存。当第二次请求的时候就从缓存中获取。
如果过期了，浏览器会询问服务器是否更改，（依据是依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not
Modified），就继续使用缓存，反之将最新文件返回到浏览器。

## 页面渲染

在得到HTML,CSS,JS之后，就由浏览器去绘制页面即可。

# 如何理解Java程序使用Unicode字符集编写

Java字符和字符串存在于以下几个地方：

Java源码文件，*.java，可以是任意字符编码，如GBK，UTF-8
Class文件，*.class，采用的是一种改进的UTF-8编码（Modified UTF-8）
JVM，内存中使用UTF-16编码

```java
String s = String.valueOf("中文");
byte[] defaultValue=s.getBytes();//Charset.defaultCharset()为utf-8(idea设置为)     e4 b8 ad e6 96 87
byte[] unicode = s.getBytes("unicode");//unicode-big     fe ff 4e 2d 65 87
byte[] utf_8 = s.getBytes("utf-8");//                    e4 b8 ad e6 96 87
byte[] GBK = s.getBytes("GBK");//                        d6 d0 ce c4
System.out.println(encodeHex(defaultValue));
```

注意这里String s存储的Value值是 [45,78,-121,101]
但是获取的unicode是[-2,-1,78,45,101,-121] 是feff 默认的是Big的形式