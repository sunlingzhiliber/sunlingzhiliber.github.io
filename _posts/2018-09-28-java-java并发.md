---
layout:     post
title:      锁和并发
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---
在JDK中，JAVA语言为了维持顺序内部的顺序化语义，也就是为了保证程序的最终运行结果需要和在单线程严格意义的顺序化环境下执行的结果一致，程序指令的执行顺序有可能和代码的顺序不一致，这个过程就称之为指令的重排序。指令重排序的意义在于：JVM能根据处理器的特性，充分利用多级缓存，多核等进行适当的指令重排序，使程序在保证业务运行的同时，充分利用CPU的执行特点，最大的发挥机器的性能！

从java源代码到最终执行的指令序列，会经过一下的三种重排序：

> 源代码->编译器优化重排序->指令级并行重排序->内存系统重排序->最终执行的指令序列


为了解决此类额外难题，Java存储模型引入了happens-Before发则，确保并发情况下的数据正确性！通俗的说就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程中），那么A/B必须满足happens-before发则！

在说happens-before发则之前我们还得先看另外一个概念：在Java中还有一个概念叫JMMA（Java Memory Medel Action）：Java模型动作。一个Action包含：编写读、变量写、监视器加锁、释放锁、线程启动(start)、线程等待(join)。关于锁我们后续会详细介绍。

说了这么多，那究竟什么是happens-before发则呢？完整的发则如下

（1）同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。

（2）对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。

（3）对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。

（4）Thread.start()的调用会happens-before于启动线程里面的动作。

（5）Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。

（6）一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。

（7）一个对象构造函数的结束happens-before与该对象的finalizer的开始

（8）如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。


# 并发的三个概念

1. 原子性
   即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

   在java中，对基本数据类型的变量的读取和赋值操作都是原子性操作，即这些操作是不可中断的。Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
2. 可见性
   可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

   Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
   
3. 有序性
   有序性：即程序执行的顺序按照代码的先后顺序执行。

   在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

1. **基础知识**

	1.1 [并发编程的优缺点](https://juejin.im/post/5ae6c3ef6fb9a07ab508ac85)

	知识点：（1）为什么要用到并发？（优点）；（2）并发编程的缺点；（3）易混淆的概念

	1.2 [线程的状态和基本操作](https://juejin.im/post/5ae6cf7a518825670960fcc2)

	知识点：（1）如何新建线程；（2）线程状态的转换；（3）线程的基本操作；（4）守护线程Daemon；

2. **并发理论（JMM）**

	[java内存模型以及happens-before规则](https://juejin.im/post/5ae6d309518825673123fd0e)

	知识点：（1）JMM内存结构；（2）重排序；（3）happens-before规则


3. **并发关键字**

	3.1 [让你彻底理解Synchronized](https://juejin.im/post/5ae6dc04f265da0ba351d3ff)

	知识点：（1）如何使用synchronized；（2）monitor机制；（3）synchronized的happens-before关系；（4）synchronized的内存语义；（5）锁优化；（6）锁升级策略

	3.2 [让你彻底理解volatile](https://juejin.im/post/5ae9b41b518825670b33e6c4)

	知识点：（1）实现原理；（2）happens-before的关系推导；（3）内存语义；（4）内存语义的实现

	3.3 [你以为你真的了解final吗？](https://juejin.im/post/5ae9b82c6fb9a07ac3634941)

	知识点：（1）如何使用；（2）final的重排序规则；（3）final实现原理；（4）final引用不能从构造函数中“溢出”（this逃逸）

	3.4 [三大性质总结：原子性，有序性，可见性](https://juejin.im/post/5aeb022cf265da0b722af7b8)

	知识点：（1）原子性：synchronized；（2）可见性：synchronized，volatile；（3）有序性：synchronized，volatile

4. **Lock体系**

	4.1 [初识Lock与AbstractQueuedSynchronizer(AQS)](https://juejin.im/post/5aeb055b6fb9a07abf725c8c)

	知识点：（1）Lock和synchronized的比较；（2）AQS设计意图；（3）如何使用AQS实现自定义同步组件；（4）可重写的方法；（5）AQS提供的模板方法；

	4.2 [深入理解AbstractQueuedSynchronizer(AQS)](https://juejin.im/post/5aeb07ab6fb9a07ac36350c8)

	知识点：（1）AQS同步队列的数据结构；（2）独占式锁；（3）共享式锁；

	4.3 [再一次理解ReentrantLock](https://juejin.im/post/5aeb0a8b518825673a2066f0)

	知识点：（1）重入锁的实现原理；（2）公平锁的实现原理；（3）非公平锁的实现原理；（4）公平锁和非公平锁的比较

	4.4 [深入理解读写锁ReentrantReadWriteLock](https://juejin.im/post/5aeb0e016fb9a07ab7740d90)

	知识点：（1）如何表示读写状态；（2）WriteLock的获取和释放；（3）ReadLock的获取和释放；（4）锁降级策略；（5）生成Condition等待队列；（6）应用场景

	4.5 [详解Condition的await和signal等待/通知机制](https://juejin.im/post/5aeea5e951882506a36c67f0)

	知识点：（1）与Object的wait/notify机制相比具有的特性；（2）与Object的wait/notify相对应的方法；（3）底层数据结构；（4）await实现原理；（5）signal/signalAll实现原理；（6）await和signal/signalAll的结合使用；

	4.6 [LockSupport工具](https://juejin.im/post/5aeed27f51882567336aa0fa)

	知识点：（1）主要功能；（2）与synchronized阻塞唤醒相比具有的特色；


5. **并发容器**

	5.1 [并发容器之ConcurrentHashMap(JDK 1.8版本)](https://juejin.im/post/5aeeaba8f265da0b9d781d16)

	知识点：（1）关键属性；（2）重要内部类；（3）涉及到的CAS操作；（4）构造方法；（5）put执行流程；（6）get执行流程；（7）扩容机制；（8）用于统计size的方法的执行流程；（9）1.8版本的ConcurrentHashMap与之前版本的比较

	5.2 [并发容器之CopyOnWriteArrayList](https://juejin.im/post/5aeeb55f5188256715478c21)

	知识点：（1）实现原理；（2）COW和ReentrantReadWriteLock的区别；（3）应用场景；（4）为什么具有弱一致性；（5）COW的缺点；

	5.3 [并发容器之ConcurrentLinkedQueue](https://juejin.im/post/5aeeae756fb9a07ab11112af)

	知识点：（1）实现原理；（2）数据结构；（3）核心方法；（4）HOPS延迟更新的设计意图

	5.4 [并发容器之ThreadLocal](https://juejin.im/post/5aeeb22e6fb9a07aa213404a)

	知识点：（1）实现原理；（2）set方法原理；（3）get方法原理；（4）remove方法原理；（5）ThreadLocalMap

	[一篇文章，从源码深入详解ThreadLocal内存泄漏问题](https://www.jianshu.com/p/dde92ec37bd1)

	知识点：（1）ThreadLocal内存泄漏原理；（2）ThreadLocal的最佳实践；（3）应用场景

	5.5 [并发容器之BlockingQueue](https://juejin.im/post/5aeebd02518825672f19c546)

	知识点：（1）BlockingQueue的基本操作；（2）常用的BlockingQueue；

	[并发容器之ArrayBlockingQueue和LinkedBlockingQueue实现原理详解](https://juejin.im/post/5aeebdb26fb9a07aa83ea17e)

6. **线程池（Executor体系）**

	6.1 [线程池实现原理](https://juejin.im/post/5aeec0106fb9a07ab379574f)

	知识点：（1）为什么要用到线程池？（2）执行流程；（3）构造器各个参数的意义；（4）如何关闭线程池；（5）如何配置线程池；

	6.2 [线程池之ScheduledThreadPoolExecutor](https://juejin.im/post/5aeec106518825670a10328a)

	知识点：（1）类结构；（2）常用方法；（3）ScheduledFutureTask；（3）DelayedWorkQueue;

	6.3 [FutureTask基本操作总结](https://juejin.im/post/5aeec249f265da0b886d5101)

	知识点：（1）FutureTask的几种状态；（2）get方法；（3）cancel方法；（4）应用场景；（5）实现 Runnable接口

7. **原子操作类**

	7.1  [Java中atomic包中的原子操作类总结](https://juejin.im/post/5aeec351518825670a103292)

	知识点：（1）实现原理；（2）原子更新基本类型；（3）原子更新数组类型；（4）原子更新引用类型；（5）原子更新字段类型

8. **并发工具**

	8.1 [大白话说java并发工具类-CountDownLatch，CyclicBarrier](https://juejin.im/post/5aeec3ebf265da0ba76fa327)

	知识点：（1）倒计时器CountDownLatch；（2）循环栅栏CyclicBarrier；（3）CountDownLatch与CyclicBarrier的比较

	8.2 [大白话说java并发工具类-Semaphore，Exchanger](https://juejin.im/post/5aeec49b518825673614d183)

	知识点：（1）资源访问控制Semaphore；（2）数据交换Exchanger

9. **并发实践**

	9.1 [一篇文章，让你彻底弄懂生产者--消费者问题](https://juejin.im/post/5aeec675f265da0b7c072c56)
 