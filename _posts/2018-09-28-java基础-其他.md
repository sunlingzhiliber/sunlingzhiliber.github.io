---
layout:     post
title:      java-基础编程
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
---

# 枚举

其本质依然是类，但是却在类的基础删添加了特殊的约束，而这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。

在枚举出来之前，我们通过`public static final`来定义枚举。

```java
public class Day {

    public static final int MONDAY =1;

    public static final int TUESDAY=2;

    public static final int WEDNESDAY=3;

    public static final int THURSDAY=4;

    public static final int FRIDAY=5;

    public static final int SATURDAY=6;

    public static final int SUNDAY=7;

}
enum Day {
    MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```

具体是如何实现的类：

我们在使用关键字`enum`创建枚举之后，编译器会将该枚举编译成`java.lang.Enum`类。

# 异常和错误

>异常实现程序的健壮性

 Java标准库中建了一些通用的异常，这些类都以Throwable为顶层父类。
 Throwable又派生出Error类和Exception类。根据类的派生关系，我们可以对Throwable进行分类：
 Error:代表了JVM本身的错误，这些错误不能被程序员通过代码进行处理，Error很少出现且难以处理。
 Exception：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

 ![error](/assets/images/something/error.png)

 另外我们可以根据JavaC对于异常的处理要求，将Throwable分为另类：
 非检查异常：Error以及RuntimeException，这些异常，在javac编译时，并不会提示与发现这些异常。当然我们也不建议通过异常不获取去处理这些错误。因为这些错误往往是代码本身就存在问题，我们应该修改代码以避免错误。
 检查异常：JavaC强制要求为此类异常做异常捕获与处理，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。

那么我们如何对异常进行处理呢？有两种方法
一种方法是利用try..catch..finally进行处理，另一种是throws异常声明 交给函数调用者caller去解决

```java
public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{
     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。
}

public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{
     try {

     }catch(ExceptionType1 ex1){
         //dosomething
     }catch(ExceptionType2 ex2){
         //dosomething
     }finally{
         //清理工作
     }
}

```



# 反射

 >反射是框架设计的灵魂

Java的反射机制是在运行状态中，你都可以获取任意一个类，任意一个对象，并对它进行操作。

```java
Class stuClass3 = Class.forName("fanshe.Student");
```

Java反射的核心在于，JVM在运行的时候才会动态的加载类，并调用其方法访问属性。它不需要预先知道运行对象是谁，完全取决于`Class.forName("类型")`中定义的类型字符串。

反射避免了`写死`这种操作，降低了程序的耦合性，给了程序更大的灵活性。

举个列子：工厂模式加配置文件，我们就可以加载不同的子类，不管子类新增多少，我们只需要修改配置文件，不需要修改代码。

常见的应用场景还有：

- 加载数据库驱动（不同的数据库厂商提供的JDBC）
- Spirng的IOC容器，通过XML配置或者注解的方式来动态创建类
- 工厂方法


# 泛型

>本质是，将类型由原来的具体 变成 类型参数化 ，提高代码的重用性，

泛型的形式包括
`<T> <E> <K> <V> <T extends Number> <T super Number>`  用于声明 类（类名之后），方法（方法返回值之前），
`<?> <? extends Number>`(Number的子类都可以)  `<? super Number>` 通配符用于参数
在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。

泛型只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，然后利用强制转换设置对应的类型，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。

泛型信息不会进入到运行时阶段。

**对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**
 同时是没有 ~~泛型数组~~ 这一定义,但是用通配符是可以的

```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.
List<String>[] lsa = new List<String>[10]; //error，因为String会被察除
```

## 注意点

1.当泛型遇到重载,下面两个方法会出现混淆。因为String与Integer会被擦除，由此编译不通过。

```java
    public  void method(List<String> list) {  
        System.out.println("invoke method(List<String> list)");  
    }  

    public  void method(List<Integer> list) {  
        System.out.println("invoke method(List<Integer> list)");  
    }  
```
2.当泛型遇到catch，同样会出错。

**泛型的类型参数不能用在Java异常处理的catch语句中。**
`MyException<String>`和`MyException<Integer>`

3.当泛型遇到静态变量。

```java
public class StaticTest{
    public static void main(String[] args){
        GT<Integer> gti = new GT<Integer>();
        gti.var=1;
        GT<String> gts = new GT<String>();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT<T>{
    public static int var=0;
    public void nothing(T x){}
}
```

这里会打印 **2** ，因为由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。



# 注解

Java1.5引入了注解，java1.8扩大了注解的使用场景，以致于目前我们能在java代码的任何地方添加我们定义的注解。
在项目开发中，注解的使用无处不在。注解的使用简化了代码，减少了程序员的工作量。

@Target(ElementType.METHOD)

```java
ElementType.TYPE
            FIELD
            METHOD
            PARAMETER
            CONSTRUCTOR
            LOCAL_VARIABLE
            ANNOTATION_TYPE
            PACKAGE
            TYPE_PARAMETER
            TYPE_USE
            MODULE
```

同时我们还可以声明注解的执行阶段。


@Retention(RetentionPolicy.RUNTIME)
```java
RetentionPolicy.SOURCE 
               .CLASS
               .RUNTIME
```

反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口，我们可以通过反射类，从而获取经过注解描述的任何东西。






# hashCode()和equals()

1. `equals()`

用于判断两个对象的地址是否相等（即  是否是同一个对象 if(this==obj) ），调用默认的`equals()`方法相当于使用`==`方法，判断内存地址，因此我们经常需要重写父类的equals()函数：如若两个对象的内容相等，`equals()`方法则返回true，反之返回false。
诸如`String,Interger,Date`等类的`equals`函数就被进行了覆盖。

我们注意在重写equals时，必须满足以下的要求：（其实我们在重写equals时，应当同时覆盖hashCode，以保证元素的唯一性）

```text
1. 对称性：如果x.equals(y)返回是"true"，那么y.equals(x)也应该返回是"true"。
2. 反射性：x.equals(x)必须返回是"true"。
3. 类推性：如果x.equals(y)返回是"true"，而且y.equals(z)返回是"true"，那么z.equals(x)也应该返回是"true"。
4. 一致性：如果x.equals(y)返回是"true"，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是"true"。
5. 非空性，x.equals(null)，永远返回是"false"；x.equals(和x不同类型的对象)永远返回是"false"。
```

2.`hashCode()`

用于获取对象在哈希表中的索引位置， 虽然，每个Java类都包含hashCode()函数。但是，仅仅当创建并某个“HashTable”（HashMap，Hashtable，HashSet）时，该类的hashCode()才有用。
也就是说：**hashCode() 在散列表中才有用，在其它情况（线性表）下没用**。
在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。前提是散列表中

- 如果两个对象相等，那么它们的hashCode()值一定要相同；
- 如果两个对象hashCode()相等，它们并不一定equals()相等。

3.两者的关系

当不创建”类的散列表“的时候，hashCode()和equals()没有任何联系。
当创建”类的散列表“的时候，他们是由关系的：

- 1)如果两个对象equals()相等，那么它们的hashCode()值一定要相同；
- 2)如果两个对象hashCode()相等，它们并不一定equals()相等。
    因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。
- 3)如果两个对象hashCode()不相等，它们一定equals()不相等。
    因此在往散列集合中添加元素时，可以先比较hashCode(),相等后再比较equals(),提高比较的效率

# 包装类

- new Integer(123) 每次会创建新的对象
- Integer.valueOf(123) 会使用缓存池中(缓存池Integer大小默认为-128~127)的对象，多次调用会取得同一个对象的引用

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true

//注意128超出了缓存池
Integer h = Integer.valueOf(128);
Integer v = Integer.valueOf(128);
System.out.println(h == v);   // false
```

## 基本类型的缓存池

boolean values true and false
all byte values
short values between -128 and 127
int values between -128 and 127
char in the range \u0000 to \u007F



# static final 等关键字的作用

`static` 静态的，可以用来修饰 方法，类以及变量。同时也可以利用static代码块来优化程序性能。
1) 静态方法 ，静态方法不依赖对象就可以直接使用，当然因为不依赖对象，在其内部就无法使用类的非静态变量和非静态方法。
2) 静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，会在类的初次加载时初始化。
3) 静态代码块，通过控制代码运行顺序，以优化程序性能。
顺序：静态变量->静态代码块->实列变量->构造代码块->构造方法(注意继承时，父类优先)

```java
class Work {
    private static int start;
    private static int end;
    private String name;
    static {//静态代码块，只会执行一次，常用于类 属性的初始化(只用于静态变量)
        start=1;
        end=2;
    }
    {//构造代码块，每次 声明对象时调用， 优先于构造函数执行
        name="Type";
    }

    public Work(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```

------------------

`final` 无法改变的，你将无法改变这个引用，它可以用于修饰变量、方法和类。经过final修饰，JVM会对其进行优化。
1)final变量 final总是和static一起使用，用来声明一个 **只读常量** 。必须在声明的时候初始化或者在构造函数中初始化，否则会编译错误，并且不允许对其修改。
final变量应该大写。

对于集合对象为final类型时，我们可以向其添加，删除以及修改其内容， 但是不能改变它的引用

```java
public class Main {
    private static final List list = new ArrayList();
    public static void main(String[] args) throws IOException {
        list.add("String");
        list.forEach(System.out::println);
        list=null; //not valid
    }
}
```

2)final方法 fianl方法标志着不可被子类的发方法重写。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。
3)final类   final类的功能是完整的，它不能被继承。java中具有很多final类，比如String、Interger等。


# 接口和抽象类

不管是接口还是抽象类，都可以通过匿名内部类的方式访问。但是注意，不能通过抽象类和接口直接创建对象。我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。

## 抽象类

抽象类用于描述对象的行为，比如动物，动物会吃东西，但是动物具体会有是什么样的吃的行为，只有具体的动物类，如Dog，Cat才会有具体的行为。
抽象类是实现多态的一种机制。

```java
Animal cat=new Cat();
Animal dog=new Dog();
cat.eat();
dog.eat();
```

1.抽象类不可以被实列化
2.抽象类的抽象方法必须被子类实现，非抽象方法自身实现
3.子类的抽象方法不可以和父类的抽象方法同名
4.子类不需要实现父类的所有方法（可以不实现父类的非抽象方法）

## 接口类

接口是通过`interface`来实现的，因此也是不能实例化的。接口的实现类必须实现接口中定义的方法(除了接口定义的default或者static方法)，java不允许多继承，但可以实现多个接口。

1.可以通过instanceOf来判别一个类是否实现了某个接口，`if(obj instanceOf className) {doSomething()}`

## 区别和联系

## 语法层次

抽象类的定义：

```java
// 抽象类中可以包含抽象方法与非抽象方法（必须给出实现）
public abstract class Demo
{
    public String name="demo";//抽象类可以拥有任意范围的成员数据，
    abstract void foo1();
    void foo2(){
        //实现
    }
}
```

接口的定义：

```java
interface Demo
{
    // 接口中的方法自动转为public abstract
    void foo1();
    default void foo2(){
    }
    static void foo3(){
    }
}
```

在以前的版本中，接口中是不能包含具体的实现的，但是在新版的java8中为了更方便的使用接口(因为接口可以多继承的优点)，允许在接口中定义static和default方法。

当然为什么接口可以使用`default`方法?为所有实现该接口添加一个新的方法，不需要对实现类做任何修改。注意这也是和Java8提出的函数式接口相对应的，利用接口的default方法为接口添加新的可以接受FunctionalInterface参数的方法，使它们更便于以函数式风格使用。

## 设计层次

从设计的层面来说，具有如下的不同点

1.`抽象层次不同`。抽象类是对类的抽象，接口是对行为的抽象。抽象类是是对类整体进行抽象，包括属性和行为。但是接口只是对类的局部(行为)进行抽象。

2.`应用情景不同`。抽象类描述的都是具有相似特点的类，而接口可以横跨不同的类。
抽象类包含着继承关系，说明了父类和派生类有一定的关系，及(派生类 is a kind of 父类)
接口只是说明，你实现了这种接口，你就必须会这个接口定义的方法。

java注解和普通的修饰符(public、static、void等)的使用方式没有多大的区别。

# 基本语法

```java
//声明Test注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
}
```

@Target用来约束注解可以应用的地方，基本上你能想到的所有地方都可以使用注解。

@Rentention用来约束注解的生命周期，分别有三个值，分别是源码级别、类文件级别和运行时注解，其含义如下：

SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里），如Lombok的@Data注解

CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等

RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。

注解内部也可以定义其他元素，方便处理器使用。支持的元素类型包括:

- 所有的基础类型(int,float,boolean,byte,double,char,long,short)
- String
- Class
- enum
- Annotation
- 上述类型的数组

针对内部元素，我们必须有确定的值。也就是说。元素必须有default值，或者在使用注解时赋值。






# JSR-Java Specification Requests

## JSR-250

@PostConstruct 
相当于init-method,使用在方法上，当Bean初始化之前时执行。

@PreDestroy
相当于destory-method，使用在方法上，当Bean销毁之前执行。

@Resource
默认按名称装配,当找不到名称匹配的bean再按类型装配.
可以写在成员属性上,或写在setter方法上
可以通过@Resource(name="beanName") 指定被注入的bean的名称, 要是未指定name属性, 默认使用成员属性的变量名,一般不用写name属性.
@Resource(name="beanName")指定了name属性,按名称注入但没找到bean, 就不会再按类型装配了.

## JSR-330
@Inject，按类型装配，功能比@Autowired少，没有使用的必要。



# 缓存

推荐资源：我的技术博客专栏“重新学习MySQL和Redis”，《Redis设计与实现》

在实际的开发中，我们经常需要对数据库进行读取、添加以及修改。但是当数据访问量大凭此的增大时，过度的数据库操作会称为系统的性能瓶颈，甚至会压垮数据仓库，从而使整个程序卡死。

因此我们在Application与数据库之间添加了cache，以此降低数据库的压力

client->application->DB  编程了 client->application->cache->DB

cache的处理机制大概包括以下的几种：

- Cache Aside
- Read Through
- Write Through
- Write Behind Caching
 
当然引入了cache，并将增加系统的复杂性，也会衍生出各样的问题。

## Cache Aside

这种模式处理缓存通常都是先从数据库缓存查询，如果缓存没有命中则从数据库中进行查找。

当查询发现存在缓存时，直接从缓存中提取。
当查询发现缓存没有数据时，从DB中读取，并将数据更新到cache中。

当写、更新操作时，直接操作数据库，然后修改缓存中对应的值

## Read Through

Read Through 强调`每次`都从`缓存`中请求数据。

如果缓存没有数据，则它负责使用底层提供程序插件从数据库中检索数据。
检索数据后，缓存会自行更新并将数据返回给调用应用程序。
使用Read Through 有一个好处。我们总是从key中获取数据，调用的Application是不知道数据库的存在的，由数据库来进行缓存的处理。这使代码更加清晰，简单，但是这需要开发人员给编写相关的程序插件，增加了开发的难度性。

## Write Through 

Write Through模式和Read Through模式类似，当数据发生更新的时候，先去Cache里面进行更新，如果命中了，则先更新缓存再由Cache方来更新database。如果没有命中的话，就直接更新Cache里面的数据。

## Write Behind Caching

Write Behind Caching 这种模式通常是先将数据写入到缓存里面，然后再异步的写入到database中进行数据同步，这样的设计既可以直接的减少我们对于数据的database里面的直接访问，降低压力，同时对于database的多次修改可以进行合并操作，极大的提升了系统的承载能力。

但是这种模式处理缓存数据具有一定的风险性，例如说当cache机器出现宕机的时候，数据会有丢失的可能。

# 序列化和反序列化

序列化：将一个对象转成一串二进制表示的字节数组，通过保存或者转移这些字节数据来达到持久化的目的。
反序列化：将字节数组重新构建为对象。

那我们做序列化和反序列化是为了什么呢？ 为了 **持久化**。持久化，就是我们将内存中的对象给 ~~持久~~ 的存储起来。这里我们就有个疑问？我们不用使用序列化 也可以将对象存储到文件中，那么为什么需要序列化呢?

- 存储到数据库\文件中
- 网络传输
- RMI(remote method invocation,它是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上)传输对象
- 读取JavaBean状态

当一个类实现了接口Serilizable，这个对象就可以实现序列化和反序列化。

同时这个类我们并不想它的所有字段都进行序列化，由此我们可以用transient来修饰变量。[典型列子,ArrayList](#arraylist)

注意transient要和接口java.io.Serializable一起使用，

## JSON序列化的JAVA实现

给了一个Java对象，我们应该如何把该对象转化为JSON对象呢？利用反射！！

对于这个java对象我们是不知道他的字段的，所以我们不能使用set和get等方法来取值，赋值。我
们利用反射的`getDeclaredFields()`获取声明的字段。
然后对其进行赋值取值，最终将其转化为JSON对象。(当然其中我们要注意一些嵌套、泛型之类的问题)