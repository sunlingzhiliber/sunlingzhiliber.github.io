---
layout:     post
title:      java-内存管理
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 面试之路
    - JVM
---

# 内存模型

 计算机在执行程序时，指令的执行实在CPU中执行的，而数据是存储在内存中的。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

## CPU缓存

 CPU缓存的出现是为了解决 **CPU运算速度和内存读写速度不一致的矛盾** 
 CPU大多数情况下不会直接读取内存，而是会访问CPU缓存。它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。
 当然我们要知道这种机制实现的基础是：我们将要访问的数据应该是相邻的这一认识。

## CPU缓存冲突问题

多核CPU处理同一个数据时，必然会发生不一致问题。因此CPU制作商制定了一个规则：~~当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效~~。

# Java内存模型

在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。

　　Java内存模型规定所有的变量都是存在主存当中（物理内存），每个线程都有自己的工作内存（CPU高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

# Java运行时的内存划分

![JVM](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181024212730.png)

## 程序计数器

记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

## 虚拟机栈

虚拟机栈由一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。
每创建一个栈帧压栈，当一个方法执行完毕之后则出栈。

> - 如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 `StackOverflowError`
> - 若线程执行过程中栈帧大小超出虚拟机栈限制，则会抛出 StackOverFlowError。
> - 若虚拟机栈允许动态扩展，但在尝试扩展时内存不足，或者在为一个新线程初始化新的虚拟机栈时申请不到足够的内存，则会抛出 OutOfMemoryError。

![虚拟机栈图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/31.jpg)

每个栈帧里面包括：
1.局部变量表：用来存储方法中的局部变量(非静态变量、函数形参)。当变量为基本类型时，直接存储值，当变量为引用类型时，存储指向具体对象的引用。
2.操作数栈：一个用于操作数的栈结构
3.指向运行时常量池的引用：程序执行时，可能会用到常量池中的引用。
4.方法返回地址：存储方法执行完成后的返回地址。

## 本地方法栈

本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。

`本地方法`：一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

那么我们为什么要使用本地方法呢？

- 与java环境之外的东西进行交互
- 与操作系统进行交互

## Java堆

Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。数组的分配也在堆中。

这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用分代回收算法，所有堆内存也分为 新生代、老年代，可以方便垃圾的准确回收。

## 方法区

在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。

方法区存储的内容包括：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。

## 常量池

运行时常量池是方法区的一部分，其中存放了一些符号引用。当 new 一个对象时，会检查这个区域是否有这个符号的引用。

# 类的加载过程

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 七个阶段。

其中类的加载过程包括：加载、验证、准备、解析、初始化 五个阶段。
在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析的阶段则不确定。它在某些情况下，可以晚于初始化进行，这是为了
支持java语言的运行时绑定。
>静态绑定：编译时绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。
>动态绑定：即运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是动态绑定的。

## 加载

1.通过类名来获取其定义的二进制字节流。
2.将字节流所代表的静态存储结构转化为方法区的运行时数据结构。

>jvm运行时数据区分为: 方法区、堆、虚拟机stack、本地方法stack、程序计数器。其中方法区是是每个线程共享的，用于存储：被虚拟机加载的类信息、常量、静态变量。

3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法去中的这些数据的入口。

### 类的加载机制

jvm是如何把数据加载到内存中的呢？是通过`类加载器`。

Classloader是用来加载class的，它负责将Class的字节码形式转换为内存形式的Class对象。字节码来自于磁盘中的.class文件，来自jar包中的class文件，也可以来自远程服务器提供的字节流，字节码的本质是一个字节数组。(byte[]->class)

类加载器具有延迟加载的特点，及JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。

>比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载


java提供了这么几种类加载器，同时这些加载器之间存在继承关系。

- 启动类加载器(Bootstrap ClassLoader),复杂加载JVM运行时的核心类，常见的库包括`java.util.*,java.io.*,java.nio.*,java.lang.*`等。这些类通常位于`JDK\jre\lib\rt.jar`文件中，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库。启动类加载器是无法被Java程序直接引用的。

- 扩展类加载器(Extenion ClassLoader)，负责加载JVM扩展类，比如`Swing,内置js引擎，xml解析器`。这些类存放在`JDK\jre\lib\ext`目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。开发者可以直接使用扩展类加载器。

- 应用程序类加载器(Application ClassLoader),它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载.

- 自定义类加载器

那些位于网络上静态文件服务器提供的 jar 包和 class文件，jdk 内置了一个 URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用 URLClassLoader 来加载远程类库了。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。


#### 双亲委派模式

如果一个类加载器得到了类的加载请求，首先他不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

![双亲委派模式图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181030104642.png)

这就是我们说得`双亲委派模式`，那么这种模式的好处是什么呢？

>同一个类的定义：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。

Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了`Object类在程序中的各种类加载器中都是同一个类`。

## 验证

验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。
文件格式的验证、元数据的验证、字节码验证和符号引用验证。

- 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
- 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
- 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。
这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

当然如果用final形容的变量，在编译时Javac将会为value生成ConstantValue属性。

```java
public static final int value = 3；
```

在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。

## 解析

解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。这就是我们当年学编译原理的“链接”阶段。

>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

## 初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。

## 总结

整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

# java值传递和引用传递

数据在内存中的存储，是依赖于数据类型来划定存储形式和存储位置的。那么，java的数据类型有什么呢？

1.基本数据类型：
    4种整数类型：byte，short，int，long
    2种浮点类型:float 、double
    1种字符类型：char
    1中布尔类型：boolean

2.引用类型：引用存放着实际内容所在地址的地址值的一种数据形式。
    类
    接口
    数组

有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得了解JVM的内存划分以及每部分的职能。

![Java程序执行内存图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181026144814.jpg)

从上面的程序运行图，我们可以看出JVM在内存分配时，涉及到这些地方：

- 堆
- 栈
- 静态方法区
- 常量区

java当中只存在值传递，不存在引用传递。都是一种副本传递

如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。

如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。

# OOM分析

OOM(Out of Memory)

- 堆内存溢出

无限制的创建新的对象，heap将溢出。

- 元数据(MetaSpace)内存溢出

JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 MetaSpace 。
无限制的创建类，MetaSpace将溢出。

# 垃圾回收

垃圾回收，涉及到三件事情：

- 哪种内存需要回收
- 什么时候回收
- 怎么回收
