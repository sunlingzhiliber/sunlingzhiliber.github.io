---
layout:     post
title:      分布式
date:       2018-07-10
author:     Liber Sun
header-img: img/post-basic.jpg
catalog: true
tags:
    - 分布式
---

"分布式系统"，是涉及多个进程协作才能提供一个完整功能的系统。
"分布式系统"是一种其组件位于不同的联网计算机上的系统，然后通过互相传递消息来进行通信和协调。为了达到共同的目标，这些组件会相互作用。

那么我们传统的"单程序+单数据库"组合的系统，是不是"分布式系统"呢？是的，它也是一个涉及多个进程协作才能提供一个完整功能的系统，"麻雀虽小五脏俱全"。

分布式就是将整个系统拆分为不同的服务，然后将这些服务放到不同的服务器上，减轻单服务器的压力，提高并发量和性能。

# 分布式和服务化模式

什么是"分布式系统"？如果一下子就想到微服务、注册中心，就意味着你把服务化的模式(SOA,微服务)和分布式系统错误的划上了等号。

什么是服务化？服务化的`本质`是`分而治之`，首先我们需要进行拆分，然后才能进行治理。在拆分的过程中，高内聚，低耦合的思想就起了一个非常重要的作用，我们要求
拆分之后的各个部分之间协作的复杂度应该在一个比较低的程度。而且往往拆分并不是一次性的拆分，往往需要在不断的实践中，循序渐进的拆分。
而我们采用了何种服务模式(SOA、微服务等)，并不重要。

可以看到服务化体现了“分治”的效果，这也是分布式系统的核心思想，因此从“分治”这个本质上来看，服务化的确是分布式系统，但分布式系统不仅仅停留在那些服务化的模式上。

我们在解决一个问题的时候，需要做到拆分，通过梳理、归类，将不同的紧密相关的部分收敛到一个独立的逻辑体中。

# 分布式和中间件

又或许一提到"分布式系统"，我们就想到了MQ(消息队列)框架，RPC(Remote Procedure Call)框架或者DAL(Distributed Data Access Layer)框架，这样我们就把中间件和分布式系统划上了等号。

这里我们要认识到，中间件起了一个什么样的作用？标准化的作用!!!
中间件承载了标准化思想，在一定成都上起到了引导和约束的作用，以此减少了系统的复杂成都和协作成本。

- MQ框架标准化了不同应用程序间`非实时异步通信`的方式。
- RPC框架标准化了不同应用程序间实时通讯的方式。
- DAL框架标准化了应用程序和数据库之间通讯的方式。

为什么我们需要标准化？这也是中间件存在的一个价值：避免我们将精力过多的花费在某个子功能下众多差异不大的选项中。
以DAL为例，标准化了访问数据库的过程；据库访问框架的作用是为了标准化操作不同数据库的差异，使得上层应用程序不用纠结于该怎么与mysql交互或者该怎么与SQL SERVER交互。

分布式系统必定会使用中间件，但分布式系统绝不仅仅是用了什么中间件。要了解每个中间件做了什么，以及它带来的优点和缺点，这样你才能从不同的，日新月异的框架中选出真正适合当前系统的技术框架。

## RPC

RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
比如两个不同的服务A,B部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。

使用RPC，能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行orderService.buy("HHKB键盘")时，实质上调用的是远端的服务。

在RPC框架中，存在三个主要角色，分别是Provider、Consumer以及Registry。
实现RPC我们需要用到的技术涉及到：

- 动态代理,生成client和server。
- 序列化，传输java对象需要序列化
- NIO，基于Netty的IO通信框架
- 服务注册中心 ，Redis、Zookeeper、Consul、Etcd。

## MQ

MQ(MessageQueen),消息队列是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中的重要组成组建，使用消息队列主要是为了异步处理请求提高系统性能和消峰、降低系统耦合程度。

当然我们要意识到消息队列是一种FIFO的数据结构，因此我们消费的时候必须按照顺序消费，及生产者发送消息1，2，3，消费者必须按照1，2，3来消费。但是我们是不能保证消费的顺序一定的正确，以及我们不能保证消息不被重复消费，或者消息的传输的丢失乃至于数据不一致等等问题，因此引入MQ，务必会提高系统的复杂程度。

### RabbitMQ

RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。
我们也将以RabbitMQ为案列来讲解消息队列。

1.生产者和消费者

一个消息一般由两部分组成：消息头和消息体。消息头由一系列的属性组成，属性包括routing-key、priority、delivery-mode等。生产者把消息交给MQ之后，MQ会将消息发给感兴趣的消费者

2.exchange(交换器)

在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。

Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中（根据routing-key），如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。

3.消息队列

Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。

![RabbitMQ使用流程](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181217212701.jpg)


# Dubbo

Dubbo是一款开源的RPC框架，提供了三大核心能力：面向接口的远程方法调用，容错和负载均衡，以及服务自动注册和发现。Dubbo致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。

![Dubbo架构图](https://raw.githubusercontent.com/sunlingzhiliber/imgstore/master/20181126173006.png)

调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

# zookeeper

ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，是 Google Chubby 的开源实现。
分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协
调/通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列
等功能。

# 限流

要实现分布式全局限流的效果，最简单的实现方式就是：利用第三方组建来记录请求的次数，而Redis就非常适合这样的场景

- 每次请求时将当前时间(精确到秒)作为 Key 写入到 Redis 中，超时时间设置为 2 秒，Redis 将该 Key 的值进行自增。
- 当达到阈值时返回错误。
- 写入 Redis 的操作用 Lua 脚本来完成，利用 Redis 的单线程机制可以保证每个 Redis 请求的原子性。

# 一致性

一致性可以理解为所有的结点都访问到最新版本的数据，这在单机模式下非常容易实现，利用共享内存和锁即可实现。但是单机存储会存在两个限制：

- 1） 单机不可用，系统整体不可用
- 2） 系统的吞吐量受限于单机的计算能力

消除这两个限制的方法是用多机来存储数据的多个副本，负责更新的客户端会同时更新数据的多个副本，于是问题就来了，多机之间的网络可能无法连接，当负责更新的客户端无法同时到连接多个机器时，如何能保证所有客户端都能读到最新版本的数据？

# CAP理论

任何基于网络的数据共享系统最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个，三个特性的定义如下：

- 数据一致性：等同于所有节点拥有数据的最新版本
- 可用性：数据具备高可用性
- 分区容忍：容忍网络出现分区，分区之间网络不可达

在大规模的分布式网络下，分区容忍是必须接受的现实。因此我们只能在一致性和可用性中做出选择。CAP似乎对于分布式系统给出了一个悲观的结局。但是我们要认识到

>CAP理论是对分布式系统中一个数据无法同时达到可用性和一致性的断言，而一个系统中往往存在很多类型的数据，部分数据（譬如银行账户中的余额）是需要强一致性的，而另外一部分数据（譬如银行的总客户数）并不要求强一致性，所以拿CAP理论来划分整个系统是不严谨的， CAP理论带来的价值是指引我们在设计分布式系统时需要区分各种数据的特点，并仔细考虑在小概率的网络分区发生时究竟为该数据选择可用性还是一致性。

-------------------------------------------

>对CAP理论的另外一种误读是系统设计时选择其一而完全不去优化另外一项，可用性和一致性的取值范围并不是只有0和1，可用性的值域可以定义成0到100%的连续区间，而一致性也可分为强一致性、弱一致性、读写一致性、最终一致性等多个不同的强弱等级，细想下去CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到。

## Paxos协议

无法达到同时达到强一致性和极致可用性，但我们可以根据数据类型在二者中选择其一后去优化另外一个，Paxos协议就是一种在保证强一致性前提下把可用性优化到极限的算法。

只要系统中2f+1个节点中的f+1个节点可用，那么系统整体就可用并且能保证数据的强一致性，它对于可用性的提升是极大的。

具体步骤如下：

1. Proposer选择一个提案编号n，然后向半数以上的Acceptors发送编号为n的prepare请求。
2. 如果一个Acceptor收到一个编号为n 的prepare请求，且 n 大于它已经响应的所有prepare请求的编号，那么它就会保证不会再通过(accept)任何编号小于 n 的提案，同时将它已经通过的最大编号的提案(如果存在的话)作为响应。

3. 如果Proposer收到来自半数以上的Acceptor对于它的prepare请求(编号为n )的响应，那么它就会发送一个针对编号为 n ，value值为 v 的提案的accept请求给Acceptors，在这里 v 是收到的响应中编号最大的提案的值，如果响应中不包含提案，那么它就是任意值。
4. 如果Acceptor收到一个针对编号n 的提案的accept请求，只要它还未对编号大于 n 的prepare请求作出响应，它就可以通过这个提案。

## ZAB协议

Paxos协议虽然是完备的，但要把它应用到实际的分布式系统中还有些问题要解决：

- 在多个Proposer的场景下，Paxos不保证先提交的提案先被接受，实际应用中要保证多提案被接受的先后顺序怎么办？
- Paxos允许多个Proposer提交提案，那有可能出现活锁问题，出现场景是这样的：提案n在第二阶段还没有完成时，新的提案n+1的第一阶段prepare请求到达Acceptor，按协议规定Acceptor将响应新提案的prepare请求并保证不会接受小于n+1的任何请求，这可能导致提案n将不会被通过，同样在n+1提案未完成第二阶段时，假如提案n的提交者又提交了n+2提案，这可能导致n+1提案也无法通过。
- Paxos协议规定提案的值v只要被大多数Acceptor接受过，后续的所有提案不能修改值v，那现实情况下我还要修改v值怎么办？

ZooKeeper的核心算法ZAB通过一个简单的约束解决了前2个问题：所有提案都转发到唯一的Leader（通过Leader选举算法从Acceptor中选出来的）来提交，由Leader来保证多个提案之间的先后顺序，同时也避免了多Proposer引发的活锁问题。

ZAB引入Leader后也会带来一个新问题： Leader宕机了怎么办？其解决方案是选举出一个新的Leader。

从保证一致性的算法核心角度看ZAB确实是借鉴了Paxos的多数派思想，但它提供的全局时序保证以及ZooKeeper提供给用户可修改的znode才让Paxos在开源界大放异彩，所以ZAB的价值不仅仅是提供了Paxos算法的优化实现，也难怪ZAB的作者一直强调ZAB和Paxos是不一样的算法。

## 总结

CAP理论告诉我们在分布式环境下网络分区无法避免，需要去权衡选择数据的一致性和可用性，Paxos协议提出了一种极其简单的算法在保障数据一致性时最大限度的优化了可用性，ZooKeeper的ZAB协议把Paxos更加简化，并提供全局时序保证，使得Paxos能够广泛应用到工业场景。

# SpirngBoot+Dubbo+zookeeper搭建一个简单的分布式服务

## 1.搭建zookeeper环境

搭建zookeeper环境，并启动zookeeper。

## 2.定义服务接口

创建项目，
创建接口类，
将项目打包为jar包一共其他项目使用(Maven install)

## 3.创建服务提供者(provider)

```text
# 配置端口
server.port=8333

spring.dubbo.application.name=dubbo-provider
spring.dubbo.application.registry=zookeeper://ip地址:2181
```

实现接口类
启动服务提供者

## 4.实现服务消费者(consumer)

创建SpringBoot项目，引入dubbo、zookeeper以及接口依赖的jar包
在application.properties中配置dubbo的相关信息
编写@Controller;
启动服务消费者；
